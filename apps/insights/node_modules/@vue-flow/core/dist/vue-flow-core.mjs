import { toRef as me, readonly as ui, customRef as ci, ref as ue, getCurrentScope as di, onScopeDispose as Zt, unref as A, isRef as fi, toRefs as Cr, watch as pe, computed as le, getCurrentInstance as dn, onMounted as We, markRaw as ht, nextTick as et, onBeforeMount as Mr, defineComponent as ve, onUnmounted as hi, openBlock as ae, createElementBlock as de, normalizeClass as it, renderSlot as Ne, h as fe, provide as mt, onBeforeUnmount as gi, normalizeStyle as De, createCommentVNode as Te, createElementVNode as yt, mergeProps as kr, createBlock as rt, resolveDynamicComponent as $r, Fragment as ze, createTextVNode as Tr, toDisplayString as zn, useAttrs as Pr, Teleport as Or, inject as qe, reactive as Ir, effectScope as vi, renderList as Tt, resolveComponent as pi, createVNode as Fe, watchEffect as po, withCtx as je, useSlots as Ar } from "vue";
function Bt(e) {
  return di() ? (Zt(e), !0) : !1;
}
function se(e) {
  return typeof e == "function" ? e() : A(e);
}
const mi = typeof window < "u", Dr = (e) => typeof e < "u", yi = () => {
};
function zr(e, t) {
  function n(...o) {
    return new Promise((i, r) => {
      Promise.resolve(e(() => t.apply(this, o), { fn: t, thisArg: this, args: o })).then(i).catch(r);
    });
  }
  return n;
}
const xi = (e) => e();
function Br(e = xi) {
  const t = ue(!0);
  function n() {
    t.value = !1;
  }
  function o() {
    t.value = !0;
  }
  const i = (...r) => {
    t.value && e(...r);
  };
  return { isActive: ui(t), pause: n, resume: o, eventFilter: i };
}
function mo(e, t = !1, n = "Timeout") {
  return new Promise((o, i) => {
    setTimeout(t ? () => i(n) : o, e);
  });
}
function Jt(...e) {
  if (e.length !== 1)
    return me(...e);
  const t = e[0];
  return typeof t == "function" ? ui(ci(() => ({ get: t, set: yi }))) : ue(t);
}
var Rr = Object.defineProperty, Vr = Object.defineProperties, Hr = Object.getOwnPropertyDescriptors, yo = Object.getOwnPropertySymbols, Lr = Object.prototype.hasOwnProperty, Fr = Object.prototype.propertyIsEnumerable, xo = (e, t, n) => t in e ? Rr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Gr = (e, t) => {
  for (var n in t || (t = {}))
    Lr.call(t, n) && xo(e, n, t[n]);
  if (yo)
    for (var n of yo(t))
      Fr.call(t, n) && xo(e, n, t[n]);
  return e;
}, Yr = (e, t) => Vr(e, Hr(t));
function Xr(e) {
  if (!fi(e))
    return Cr(e);
  const t = Array.isArray(e.value) ? new Array(e.value.length) : {};
  for (const n in e.value)
    t[n] = ci(() => ({
      get() {
        return e.value[n];
      },
      set(o) {
        if (Array.isArray(e.value)) {
          const i = [...e.value];
          i[n] = o, e.value = i;
        } else {
          const i = Yr(Gr({}, e.value), { [n]: o });
          Object.setPrototypeOf(i, e.value), e.value = i;
        }
      }
    }));
  return t;
}
function Bn(e, t = !1) {
  function n(d, { flush: h = "sync", deep: p = !1, timeout: N, throwOnTimeout: f } = {}) {
    let g = null;
    const v = [new Promise((b) => {
      g = pe(
        e,
        (y) => {
          d(y) !== t && (g == null || g(), b(y));
        },
        {
          flush: h,
          deep: p,
          immediate: !0
        }
      );
    })];
    return N != null && v.push(
      mo(N, f).then(() => se(e)).finally(() => g == null ? void 0 : g())
    ), Promise.race(v);
  }
  function o(d, h) {
    if (!fi(d))
      return n((y) => y === d, h);
    const { flush: p = "sync", deep: N = !1, timeout: f, throwOnTimeout: g } = h ?? {};
    let _ = null;
    const b = [new Promise((y) => {
      _ = pe(
        [e, d],
        ([M, x]) => {
          t !== (M === x) && (_ == null || _(), y(M));
        },
        {
          flush: p,
          deep: N,
          immediate: !0
        }
      );
    })];
    return f != null && b.push(
      mo(f, g).then(() => se(e)).finally(() => (_ == null || _(), se(e)))
    ), Promise.race(b);
  }
  function i(d) {
    return n((h) => !!h, d);
  }
  function r(d) {
    return o(null, d);
  }
  function l(d) {
    return o(void 0, d);
  }
  function a(d) {
    return n(Number.isNaN, d);
  }
  function s(d, h) {
    return n((p) => {
      const N = Array.from(p);
      return N.includes(d) || N.includes(se(d));
    }, h);
  }
  function u(d) {
    return c(1, d);
  }
  function c(d = 1, h) {
    let p = -1;
    return n(() => (p += 1, p >= d), h);
  }
  return Array.isArray(se(e)) ? {
    toMatch: n,
    toContains: s,
    changed: u,
    changedTimes: c,
    get not() {
      return Bn(e, !t);
    }
  } : {
    toMatch: n,
    toBe: o,
    toBeTruthy: i,
    toBeNull: r,
    toBeNaN: a,
    toBeUndefined: l,
    changed: u,
    changedTimes: c,
    get not() {
      return Bn(e, !t);
    }
  };
}
function Ze(e) {
  return Bn(e);
}
var wo = Object.getOwnPropertySymbols, Ur = Object.prototype.hasOwnProperty, Zr = Object.prototype.propertyIsEnumerable, Wr = (e, t) => {
  var n = {};
  for (var o in e)
    Ur.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && wo)
    for (var o of wo(e))
      t.indexOf(o) < 0 && Zr.call(e, o) && (n[o] = e[o]);
  return n;
};
function qr(e, t, n = {}) {
  const o = n, {
    eventFilter: i = xi
  } = o, r = Wr(o, [
    "eventFilter"
  ]);
  return pe(
    e,
    zr(
      i,
      t
    ),
    r
  );
}
var Kr = Object.defineProperty, jr = Object.defineProperties, Jr = Object.getOwnPropertyDescriptors, Qt = Object.getOwnPropertySymbols, wi = Object.prototype.hasOwnProperty, _i = Object.prototype.propertyIsEnumerable, _o = (e, t, n) => t in e ? Kr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Qr = (e, t) => {
  for (var n in t || (t = {}))
    wi.call(t, n) && _o(e, n, t[n]);
  if (Qt)
    for (var n of Qt(t))
      _i.call(t, n) && _o(e, n, t[n]);
  return e;
}, el = (e, t) => jr(e, Jr(t)), tl = (e, t) => {
  var n = {};
  for (var o in e)
    wi.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && Qt)
    for (var o of Qt(e))
      t.indexOf(o) < 0 && _i.call(e, o) && (n[o] = e[o]);
  return n;
};
function ut(e, t, n = {}) {
  const o = n, {
    eventFilter: i
  } = o, r = tl(o, [
    "eventFilter"
  ]), { eventFilter: l, pause: a, resume: s, isActive: u } = Br(i);
  return { stop: qr(
    e,
    t,
    el(Qr({}, r), {
      eventFilter: l
    })
  ), pause: a, resume: s, isActive: u };
}
function Rn(e) {
  var t;
  const n = se(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const eo = mi ? window : void 0;
function to(...e) {
  let t, n, o, i;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([n, o, i] = e, t = eo) : [t, n, o, i] = e, !t)
    return yi;
  Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
  const r = [], l = () => {
    r.forEach((c) => c()), r.length = 0;
  }, a = (c, d, h, p) => (c.addEventListener(d, h, p), () => c.removeEventListener(d, h, p)), s = pe(
    () => [Rn(t), se(i)],
    ([c, d]) => {
      l(), c && r.push(
        ...n.flatMap((h) => o.map((p) => a(c, h, p, d)))
      );
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    s(), l();
  };
  return Bt(u), u;
}
function nl(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
}
function bo(...e) {
  let t, n, o = {};
  e.length === 3 ? (t = e[0], n = e[1], o = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], o = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const {
    target: i = eo,
    eventName: r = "keydown",
    passive: l = !1,
    dedupe: a = !1
  } = o, s = nl(t);
  return to(i, r, (c) => {
    c.repeat && se(a) || s(c) && n(c);
  }, l);
}
function ol() {
  const e = ue(!1);
  return dn() && We(() => {
    e.value = !0;
  }), e;
}
function il(e) {
  const t = ol();
  return le(() => (t.value, !!e()));
}
function rl(e) {
  return JSON.parse(JSON.stringify(e));
}
var Eo = Object.getOwnPropertySymbols, ll = Object.prototype.hasOwnProperty, al = Object.prototype.propertyIsEnumerable, sl = (e, t) => {
  var n = {};
  for (var o in e)
    ll.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && Eo)
    for (var o of Eo(e))
      t.indexOf(o) < 0 && al.call(e, o) && (n[o] = e[o]);
  return n;
};
function ul(e, t, n = {}) {
  const o = n, { window: i = eo } = o, r = sl(o, ["window"]);
  let l;
  const a = il(() => i && "ResizeObserver" in i), s = () => {
    l && (l.disconnect(), l = void 0);
  }, u = le(
    () => Array.isArray(e) ? e.map((h) => Rn(h)) : [Rn(e)]
  ), c = pe(
    u,
    (h) => {
      if (s(), a.value && i) {
        l = new ResizeObserver(t);
        for (const p of h)
          p && l.observe(p, r);
      }
    },
    { immediate: !0, flush: "post", deep: !0 }
  ), d = () => {
    s(), c();
  };
  return Bt(d), {
    isSupported: a,
    stop: d
  };
}
function Mt(e, t, n, o = {}) {
  var i, r, l;
  const {
    clone: a = !1,
    passive: s = !1,
    eventName: u,
    deep: c = !1,
    defaultValue: d,
    shouldEmit: h
  } = o, p = dn(), N = n || (p == null ? void 0 : p.emit) || ((i = p == null ? void 0 : p.$emit) == null ? void 0 : i.bind(p)) || ((l = (r = p == null ? void 0 : p.proxy) == null ? void 0 : r.$emit) == null ? void 0 : l.bind(p == null ? void 0 : p.proxy));
  let f = u;
  t || (t = "modelValue"), f = u || f || `update:${t.toString()}`;
  const g = (b) => a ? typeof a == "function" ? a(b) : rl(b) : b, _ = () => Dr(e[t]) ? g(e[t]) : d, v = (b) => {
    h ? h(b) && N(f, b) : N(f, b);
  };
  if (s) {
    const b = _(), y = ue(b);
    return pe(
      () => e[t],
      (M) => y.value = g(M)
    ), pe(
      y,
      (M) => {
        (M !== e[t] || c) && v(M);
      },
      { deep: c }
    ), y;
  } else
    return le({
      get() {
        return _();
      },
      set(b) {
        v(b);
      }
    });
}
var cl = { value: () => {
} };
function fn() {
  for (var e = 0, t = arguments.length, n = {}, o; e < t; ++e) {
    if (!(o = arguments[e] + "") || o in n || /[\s.]/.test(o))
      throw new Error("illegal type: " + o);
    n[o] = [];
  }
  return new Wt(n);
}
function Wt(e) {
  this._ = e;
}
function dl(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var o = "", i = n.indexOf(".");
    if (i >= 0 && (o = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: o };
  });
}
Wt.prototype = fn.prototype = {
  constructor: Wt,
  on: function(e, t) {
    var n = this._, o = dl(e + "", n), i, r = -1, l = o.length;
    if (arguments.length < 2) {
      for (; ++r < l; )
        if ((i = (e = o[r]).type) && (i = fl(n[i], e.name)))
          return i;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++r < l; )
      if (i = (e = o[r]).type)
        n[i] = So(n[i], e.name, t);
      else if (t == null)
        for (i in n)
          n[i] = So(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new Wt(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), o = 0, i, r; o < i; ++o)
        n[o] = arguments[o + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (r = this._[e], o = 0, i = r.length; o < i; ++o)
      r[o].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var o = this._[e], i = 0, r = o.length; i < r; ++i)
      o[i].value.apply(t, n);
  }
};
function fl(e, t) {
  for (var n = 0, o = e.length, i; n < o; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function So(e, t, n) {
  for (var o = 0, i = e.length; o < i; ++o)
    if (e[o].name === t) {
      e[o] = cl, e = e.slice(0, o).concat(e.slice(o + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Vn = "http://www.w3.org/1999/xhtml";
const No = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Vn,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function hn(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), No.hasOwnProperty(t) ? { space: No[t], local: e } : e;
}
function hl(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Vn && t.documentElement.namespaceURI === Vn ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function gl(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function bi(e) {
  var t = hn(e);
  return (t.local ? gl : hl)(t);
}
function vl() {
}
function no(e) {
  return e == null ? vl : function() {
    return this.querySelector(e);
  };
}
function pl(e) {
  typeof e != "function" && (e = no(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], l = r.length, a = o[i] = new Array(l), s, u, c = 0; c < l; ++c)
      (s = r[c]) && (u = e.call(s, s.__data__, c, r)) && ("__data__" in s && (u.__data__ = s.__data__), a[c] = u);
  return new Ce(o, this._parents);
}
function ml(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function yl() {
  return [];
}
function Ei(e) {
  return e == null ? yl : function() {
    return this.querySelectorAll(e);
  };
}
function xl(e) {
  return function() {
    return ml(e.apply(this, arguments));
  };
}
function wl(e) {
  typeof e == "function" ? e = xl(e) : e = Ei(e);
  for (var t = this._groups, n = t.length, o = [], i = [], r = 0; r < n; ++r)
    for (var l = t[r], a = l.length, s, u = 0; u < a; ++u)
      (s = l[u]) && (o.push(e.call(s, s.__data__, u, l)), i.push(s));
  return new Ce(o, i);
}
function Si(e) {
  return function() {
    return this.matches(e);
  };
}
function Ni(e) {
  return function(t) {
    return t.matches(e);
  };
}
var _l = Array.prototype.find;
function bl(e) {
  return function() {
    return _l.call(this.children, e);
  };
}
function El() {
  return this.firstElementChild;
}
function Sl(e) {
  return this.select(e == null ? El : bl(typeof e == "function" ? e : Ni(e)));
}
var Nl = Array.prototype.filter;
function Cl() {
  return Array.from(this.children);
}
function Ml(e) {
  return function() {
    return Nl.call(this.children, e);
  };
}
function kl(e) {
  return this.selectAll(e == null ? Cl : Ml(typeof e == "function" ? e : Ni(e)));
}
function $l(e) {
  typeof e != "function" && (e = Si(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], l = r.length, a = o[i] = [], s, u = 0; u < l; ++u)
      (s = r[u]) && e.call(s, s.__data__, u, r) && a.push(s);
  return new Ce(o, this._parents);
}
function Ci(e) {
  return new Array(e.length);
}
function Tl() {
  return new Ce(this._enter || this._groups.map(Ci), this._parents);
}
function en(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
en.prototype = {
  constructor: en,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function Pl(e) {
  return function() {
    return e;
  };
}
function Ol(e, t, n, o, i, r) {
  for (var l = 0, a, s = t.length, u = r.length; l < u; ++l)
    (a = t[l]) ? (a.__data__ = r[l], o[l] = a) : n[l] = new en(e, r[l]);
  for (; l < s; ++l)
    (a = t[l]) && (i[l] = a);
}
function Il(e, t, n, o, i, r, l) {
  var a, s, u = /* @__PURE__ */ new Map(), c = t.length, d = r.length, h = new Array(c), p;
  for (a = 0; a < c; ++a)
    (s = t[a]) && (h[a] = p = l.call(s, s.__data__, a, t) + "", u.has(p) ? i[a] = s : u.set(p, s));
  for (a = 0; a < d; ++a)
    p = l.call(e, r[a], a, r) + "", (s = u.get(p)) ? (o[a] = s, s.__data__ = r[a], u.delete(p)) : n[a] = new en(e, r[a]);
  for (a = 0; a < c; ++a)
    (s = t[a]) && u.get(h[a]) === s && (i[a] = s);
}
function Al(e) {
  return e.__data__;
}
function Dl(e, t) {
  if (!arguments.length)
    return Array.from(this, Al);
  var n = t ? Il : Ol, o = this._parents, i = this._groups;
  typeof e != "function" && (e = Pl(e));
  for (var r = i.length, l = new Array(r), a = new Array(r), s = new Array(r), u = 0; u < r; ++u) {
    var c = o[u], d = i[u], h = d.length, p = zl(e.call(c, c && c.__data__, u, o)), N = p.length, f = a[u] = new Array(N), g = l[u] = new Array(N), _ = s[u] = new Array(h);
    n(c, d, f, g, _, p, t);
    for (var v = 0, b = 0, y, M; v < N; ++v)
      if (y = f[v]) {
        for (v >= b && (b = v + 1); !(M = g[b]) && ++b < N; )
          ;
        y._next = M || null;
      }
  }
  return l = new Ce(l, o), l._enter = a, l._exit = s, l;
}
function zl(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function Bl() {
  return new Ce(this._exit || this._groups.map(Ci), this._parents);
}
function Rl(e, t, n) {
  var o = this.enter(), i = this, r = this.exit();
  return typeof e == "function" ? (o = e(o), o && (o = o.selection())) : o = o.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? r.remove() : n(r), o && i ? o.merge(i).order() : i;
}
function Vl(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, o = t._groups, i = n.length, r = o.length, l = Math.min(i, r), a = new Array(i), s = 0; s < l; ++s)
    for (var u = n[s], c = o[s], d = u.length, h = a[s] = new Array(d), p, N = 0; N < d; ++N)
      (p = u[N] || c[N]) && (h[N] = p);
  for (; s < i; ++s)
    a[s] = n[s];
  return new Ce(a, this._parents);
}
function Hl() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var o = e[t], i = o.length - 1, r = o[i], l; --i >= 0; )
      (l = o[i]) && (r && l.compareDocumentPosition(r) ^ 4 && r.parentNode.insertBefore(l, r), r = l);
  return this;
}
function Ll(e) {
  e || (e = Fl);
  function t(d, h) {
    return d && h ? e(d.__data__, h.__data__) : !d - !h;
  }
  for (var n = this._groups, o = n.length, i = new Array(o), r = 0; r < o; ++r) {
    for (var l = n[r], a = l.length, s = i[r] = new Array(a), u, c = 0; c < a; ++c)
      (u = l[c]) && (s[c] = u);
    s.sort(t);
  }
  return new Ce(i, this._parents).order();
}
function Fl(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Gl() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function Yl() {
  return Array.from(this);
}
function Xl() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var o = e[t], i = 0, r = o.length; i < r; ++i) {
      var l = o[i];
      if (l)
        return l;
    }
  return null;
}
function Ul() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function Zl() {
  return !this.node();
}
function Wl(e) {
  for (var t = this._groups, n = 0, o = t.length; n < o; ++n)
    for (var i = t[n], r = 0, l = i.length, a; r < l; ++r)
      (a = i[r]) && e.call(a, a.__data__, r, i);
  return this;
}
function ql(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Kl(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function jl(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function Jl(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function Ql(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function ea(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function ta(e, t) {
  var n = hn(e);
  if (arguments.length < 2) {
    var o = this.node();
    return n.local ? o.getAttributeNS(n.space, n.local) : o.getAttribute(n);
  }
  return this.each((t == null ? n.local ? Kl : ql : typeof t == "function" ? n.local ? ea : Ql : n.local ? Jl : jl)(n, t));
}
function Mi(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function na(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function oa(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function ia(e, t, n) {
  return function() {
    var o = t.apply(this, arguments);
    o == null ? this.style.removeProperty(e) : this.style.setProperty(e, o, n);
  };
}
function ra(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? na : typeof t == "function" ? ia : oa)(e, t, n ?? "")) : xt(this.node(), e);
}
function xt(e, t) {
  return e.style.getPropertyValue(t) || Mi(e).getComputedStyle(e, null).getPropertyValue(t);
}
function la(e) {
  return function() {
    delete this[e];
  };
}
function aa(e, t) {
  return function() {
    this[e] = t;
  };
}
function sa(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function ua(e, t) {
  return arguments.length > 1 ? this.each((t == null ? la : typeof t == "function" ? sa : aa)(e, t)) : this.node()[e];
}
function ki(e) {
  return e.trim().split(/^|\s+/);
}
function oo(e) {
  return e.classList || new $i(e);
}
function $i(e) {
  this._node = e, this._names = ki(e.getAttribute("class") || "");
}
$i.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function Ti(e, t) {
  for (var n = oo(e), o = -1, i = t.length; ++o < i; )
    n.add(t[o]);
}
function Pi(e, t) {
  for (var n = oo(e), o = -1, i = t.length; ++o < i; )
    n.remove(t[o]);
}
function ca(e) {
  return function() {
    Ti(this, e);
  };
}
function da(e) {
  return function() {
    Pi(this, e);
  };
}
function fa(e, t) {
  return function() {
    (t.apply(this, arguments) ? Ti : Pi)(this, e);
  };
}
function ha(e, t) {
  var n = ki(e + "");
  if (arguments.length < 2) {
    for (var o = oo(this.node()), i = -1, r = n.length; ++i < r; )
      if (!o.contains(n[i]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? fa : t ? ca : da)(n, t));
}
function ga() {
  this.textContent = "";
}
function va(e) {
  return function() {
    this.textContent = e;
  };
}
function pa(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function ma(e) {
  return arguments.length ? this.each(e == null ? ga : (typeof e == "function" ? pa : va)(e)) : this.node().textContent;
}
function ya() {
  this.innerHTML = "";
}
function xa(e) {
  return function() {
    this.innerHTML = e;
  };
}
function wa(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function _a(e) {
  return arguments.length ? this.each(e == null ? ya : (typeof e == "function" ? wa : xa)(e)) : this.node().innerHTML;
}
function ba() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Ea() {
  return this.each(ba);
}
function Sa() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function Na() {
  return this.each(Sa);
}
function Ca(e) {
  var t = typeof e == "function" ? e : bi(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function Ma() {
  return null;
}
function ka(e, t) {
  var n = typeof e == "function" ? e : bi(e), o = t == null ? Ma : typeof t == "function" ? t : no(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), o.apply(this, arguments) || null);
  });
}
function $a() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function Ta() {
  return this.each($a);
}
function Pa() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Oa() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Ia(e) {
  return this.select(e ? Oa : Pa);
}
function Aa(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function Da(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function za(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", o = t.indexOf(".");
    return o >= 0 && (n = t.slice(o + 1), t = t.slice(0, o)), { type: t, name: n };
  });
}
function Ba(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, o = -1, i = t.length, r; n < i; ++n)
        r = t[n], (!e.type || r.type === e.type) && r.name === e.name ? this.removeEventListener(r.type, r.listener, r.options) : t[++o] = r;
      ++o ? t.length = o : delete this.__on;
    }
  };
}
function Ra(e, t, n) {
  return function() {
    var o = this.__on, i, r = Da(t);
    if (o) {
      for (var l = 0, a = o.length; l < a; ++l)
        if ((i = o[l]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = r, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, r, n), i = { type: e.type, name: e.name, value: t, listener: r, options: n }, o ? o.push(i) : this.__on = [i];
  };
}
function Va(e, t, n) {
  var o = za(e + ""), i, r = o.length, l;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var s = 0, u = a.length, c; s < u; ++s)
        for (i = 0, c = a[s]; i < r; ++i)
          if ((l = o[i]).type === c.type && l.name === c.name)
            return c.value;
    }
    return;
  }
  for (a = t ? Ra : Ba, i = 0; i < r; ++i)
    this.each(a(o[i], t, n));
  return this;
}
function Oi(e, t, n) {
  var o = Mi(e), i = o.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = o.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function Ha(e, t) {
  return function() {
    return Oi(this, e, t);
  };
}
function La(e, t) {
  return function() {
    return Oi(this, e, t.apply(this, arguments));
  };
}
function Fa(e, t) {
  return this.each((typeof t == "function" ? La : Ha)(e, t));
}
function* Ga() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var o = e[t], i = 0, r = o.length, l; i < r; ++i)
      (l = o[i]) && (yield l);
}
var Ii = [null];
function Ce(e, t) {
  this._groups = e, this._parents = t;
}
function Rt() {
  return new Ce([[document.documentElement]], Ii);
}
function Ya() {
  return this;
}
Ce.prototype = Rt.prototype = {
  constructor: Ce,
  select: pl,
  selectAll: wl,
  selectChild: Sl,
  selectChildren: kl,
  filter: $l,
  data: Dl,
  enter: Tl,
  exit: Bl,
  join: Rl,
  merge: Vl,
  selection: Ya,
  order: Hl,
  sort: Ll,
  call: Gl,
  nodes: Yl,
  node: Xl,
  size: Ul,
  empty: Zl,
  each: Wl,
  attr: ta,
  style: ra,
  property: ua,
  classed: ha,
  text: ma,
  html: _a,
  raise: Ea,
  lower: Na,
  append: Ca,
  insert: ka,
  remove: Ta,
  clone: Ia,
  datum: Aa,
  on: Va,
  dispatch: Fa,
  [Symbol.iterator]: Ga
};
function ke(e) {
  return typeof e == "string" ? new Ce([[document.querySelector(e)]], [document.documentElement]) : new Ce([[e]], Ii);
}
function Xa(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function Oe(e, t) {
  if (e = Xa(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var o = n.createSVGPoint();
      return o.x = e.clientX, o.y = e.clientY, o = o.matrixTransform(t.getScreenCTM().inverse()), [o.x, o.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const Ua = { passive: !1 }, Pt = { capture: !0, passive: !1 };
function Sn(e) {
  e.stopImmediatePropagation();
}
function gt(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Ai(e) {
  var t = e.document.documentElement, n = ke(e).on("dragstart.drag", gt, Pt);
  "onselectstart" in t ? n.on("selectstart.drag", gt, Pt) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function Di(e, t) {
  var n = e.document.documentElement, o = ke(e).on("dragstart.drag", null);
  t && (o.on("click.drag", gt, Pt), setTimeout(function() {
    o.on("click.drag", null);
  }, 0)), "onselectstart" in n ? o.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const Ht = (e) => () => e;
function Hn(e, {
  sourceEvent: t,
  subject: n,
  target: o,
  identifier: i,
  active: r,
  x: l,
  y: a,
  dx: s,
  dy: u,
  dispatch: c
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: o, enumerable: !0, configurable: !0 },
    identifier: { value: i, enumerable: !0, configurable: !0 },
    active: { value: r, enumerable: !0, configurable: !0 },
    x: { value: l, enumerable: !0, configurable: !0 },
    y: { value: a, enumerable: !0, configurable: !0 },
    dx: { value: s, enumerable: !0, configurable: !0 },
    dy: { value: u, enumerable: !0, configurable: !0 },
    _: { value: c }
  });
}
Hn.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function Za(e) {
  return !e.ctrlKey && !e.button;
}
function Wa() {
  return this.parentNode;
}
function qa(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function Ka() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function ja() {
  var e = Za, t = Wa, n = qa, o = Ka, i = {}, r = fn("start", "drag", "end"), l = 0, a, s, u, c, d = 0;
  function h(y) {
    y.on("mousedown.drag", p).filter(o).on("touchstart.drag", g).on("touchmove.drag", _, Ua).on("touchend.drag touchcancel.drag", v).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function p(y, M) {
    if (!(c || !e.call(this, y, M))) {
      var x = b(this, t.call(this, y, M), y, M, "mouse");
      x && (ke(y.view).on("mousemove.drag", N, Pt).on("mouseup.drag", f, Pt), Ai(y.view), Sn(y), u = !1, a = y.clientX, s = y.clientY, x("start", y));
    }
  }
  function N(y) {
    if (gt(y), !u) {
      var M = y.clientX - a, x = y.clientY - s;
      u = M * M + x * x > d;
    }
    i.mouse("drag", y);
  }
  function f(y) {
    ke(y.view).on("mousemove.drag mouseup.drag", null), Di(y.view, u), gt(y), i.mouse("end", y);
  }
  function g(y, M) {
    if (e.call(this, y, M)) {
      var x = y.changedTouches, D = t.call(this, y, M), V = x.length, H, I;
      for (H = 0; H < V; ++H)
        (I = b(this, D, y, M, x[H].identifier, x[H])) && (Sn(y), I("start", y, x[H]));
    }
  }
  function _(y) {
    var M = y.changedTouches, x = M.length, D, V;
    for (D = 0; D < x; ++D)
      (V = i[M[D].identifier]) && (gt(y), V("drag", y, M[D]));
  }
  function v(y) {
    var M = y.changedTouches, x = M.length, D, V;
    for (c && clearTimeout(c), c = setTimeout(function() {
      c = null;
    }, 500), D = 0; D < x; ++D)
      (V = i[M[D].identifier]) && (Sn(y), V("end", y, M[D]));
  }
  function b(y, M, x, D, V, H) {
    var I = r.copy(), Z = Oe(H || x, M), ee, X, m;
    if ((m = n.call(y, new Hn("beforestart", {
      sourceEvent: x,
      target: h,
      identifier: V,
      active: l,
      x: Z[0],
      y: Z[1],
      dx: 0,
      dy: 0,
      dispatch: I
    }), D)) != null)
      return ee = m.x - Z[0] || 0, X = m.y - Z[1] || 0, function k(E, O, z) {
        var G = Z, P;
        switch (E) {
          case "start":
            i[V] = k, P = l++;
            break;
          case "end":
            delete i[V], --l;
          case "drag":
            Z = Oe(z || O, M), P = l;
            break;
        }
        I.call(
          E,
          y,
          new Hn(E, {
            sourceEvent: O,
            subject: m,
            target: h,
            identifier: V,
            active: P,
            x: Z[0] + ee,
            y: Z[1] + X,
            dx: Z[0] - G[0],
            dy: Z[1] - G[1],
            dispatch: I
          }),
          D
        );
      };
  }
  return h.filter = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : Ht(!!y), h) : e;
  }, h.container = function(y) {
    return arguments.length ? (t = typeof y == "function" ? y : Ht(y), h) : t;
  }, h.subject = function(y) {
    return arguments.length ? (n = typeof y == "function" ? y : Ht(y), h) : n;
  }, h.touchable = function(y) {
    return arguments.length ? (o = typeof y == "function" ? y : Ht(!!y), h) : o;
  }, h.on = function() {
    var y = r.on.apply(r, arguments);
    return y === r ? h : y;
  }, h.clickDistance = function(y) {
    return arguments.length ? (d = (y = +y) * y, h) : Math.sqrt(d);
  }, h;
}
function io(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function zi(e, t) {
  var n = Object.create(e.prototype);
  for (var o in t)
    n[o] = t[o];
  return n;
}
function Vt() {
}
var Ot = 0.7, tn = 1 / Ot, vt = "\\s*([+-]?\\d+)\\s*", It = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Ae = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Ja = /^#([0-9a-f]{3,8})$/, Qa = new RegExp(`^rgb\\(${vt},${vt},${vt}\\)$`), es = new RegExp(`^rgb\\(${Ae},${Ae},${Ae}\\)$`), ts = new RegExp(`^rgba\\(${vt},${vt},${vt},${It}\\)$`), ns = new RegExp(`^rgba\\(${Ae},${Ae},${Ae},${It}\\)$`), os = new RegExp(`^hsl\\(${It},${Ae},${Ae}\\)$`), is = new RegExp(`^hsla\\(${It},${Ae},${Ae},${It}\\)$`), Co = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
io(Vt, At, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Mo,
  // Deprecated! Use color.formatHex.
  formatHex: Mo,
  formatHex8: rs,
  formatHsl: ls,
  formatRgb: ko,
  toString: ko
});
function Mo() {
  return this.rgb().formatHex();
}
function rs() {
  return this.rgb().formatHex8();
}
function ls() {
  return Bi(this).formatHsl();
}
function ko() {
  return this.rgb().formatRgb();
}
function At(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = Ja.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? $o(t) : n === 3 ? new Se(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Lt(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Lt(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Qa.exec(e)) ? new Se(t[1], t[2], t[3], 1) : (t = es.exec(e)) ? new Se(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = ts.exec(e)) ? Lt(t[1], t[2], t[3], t[4]) : (t = ns.exec(e)) ? Lt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = os.exec(e)) ? Oo(t[1], t[2] / 100, t[3] / 100, 1) : (t = is.exec(e)) ? Oo(t[1], t[2] / 100, t[3] / 100, t[4]) : Co.hasOwnProperty(e) ? $o(Co[e]) : e === "transparent" ? new Se(NaN, NaN, NaN, 0) : null;
}
function $o(e) {
  return new Se(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Lt(e, t, n, o) {
  return o <= 0 && (e = t = n = NaN), new Se(e, t, n, o);
}
function as(e) {
  return e instanceof Vt || (e = At(e)), e ? (e = e.rgb(), new Se(e.r, e.g, e.b, e.opacity)) : new Se();
}
function Ln(e, t, n, o) {
  return arguments.length === 1 ? as(e) : new Se(e, t, n, o ?? 1);
}
function Se(e, t, n, o) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +o;
}
io(Se, Ln, zi(Vt, {
  brighter(e) {
    return e = e == null ? tn : Math.pow(tn, e), new Se(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Ot : Math.pow(Ot, e), new Se(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Se(tt(this.r), tt(this.g), tt(this.b), nn(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: To,
  // Deprecated! Use color.formatHex.
  formatHex: To,
  formatHex8: ss,
  formatRgb: Po,
  toString: Po
}));
function To() {
  return `#${Je(this.r)}${Je(this.g)}${Je(this.b)}`;
}
function ss() {
  return `#${Je(this.r)}${Je(this.g)}${Je(this.b)}${Je((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Po() {
  const e = nn(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${tt(this.r)}, ${tt(this.g)}, ${tt(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function nn(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function tt(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Je(e) {
  return e = tt(e), (e < 16 ? "0" : "") + e.toString(16);
}
function Oo(e, t, n, o) {
  return o <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new $e(e, t, n, o);
}
function Bi(e) {
  if (e instanceof $e)
    return new $e(e.h, e.s, e.l, e.opacity);
  if (e instanceof Vt || (e = At(e)), !e)
    return new $e();
  if (e instanceof $e)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, o = e.b / 255, i = Math.min(t, n, o), r = Math.max(t, n, o), l = NaN, a = r - i, s = (r + i) / 2;
  return a ? (t === r ? l = (n - o) / a + (n < o) * 6 : n === r ? l = (o - t) / a + 2 : l = (t - n) / a + 4, a /= s < 0.5 ? r + i : 2 - r - i, l *= 60) : a = s > 0 && s < 1 ? 0 : l, new $e(l, a, s, e.opacity);
}
function us(e, t, n, o) {
  return arguments.length === 1 ? Bi(e) : new $e(e, t, n, o ?? 1);
}
function $e(e, t, n, o) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +o;
}
io($e, us, zi(Vt, {
  brighter(e) {
    return e = e == null ? tn : Math.pow(tn, e), new $e(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Ot : Math.pow(Ot, e), new $e(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, o = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - o;
    return new Se(
      Nn(e >= 240 ? e - 240 : e + 120, i, o),
      Nn(e, i, o),
      Nn(e < 120 ? e + 240 : e - 120, i, o),
      this.opacity
    );
  },
  clamp() {
    return new $e(Io(this.h), Ft(this.s), Ft(this.l), nn(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = nn(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${Io(this.h)}, ${Ft(this.s) * 100}%, ${Ft(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function Io(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Ft(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Nn(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const Ri = (e) => () => e;
function cs(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function ds(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(o) {
    return Math.pow(e + o * t, n);
  };
}
function fs(e) {
  return (e = +e) == 1 ? Vi : function(t, n) {
    return n - t ? ds(t, n, e) : Ri(isNaN(t) ? n : t);
  };
}
function Vi(e, t) {
  var n = t - e;
  return n ? cs(e, n) : Ri(isNaN(e) ? t : e);
}
const Ao = function e(t) {
  var n = fs(t);
  function o(i, r) {
    var l = n((i = Ln(i)).r, (r = Ln(r)).r), a = n(i.g, r.g), s = n(i.b, r.b), u = Vi(i.opacity, r.opacity);
    return function(c) {
      return i.r = l(c), i.g = a(c), i.b = s(c), i.opacity = u(c), i + "";
    };
  }
  return o.gamma = e, o;
}(1);
function Ue(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
var Fn = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Cn = new RegExp(Fn.source, "g");
function hs(e) {
  return function() {
    return e;
  };
}
function gs(e) {
  return function(t) {
    return e(t) + "";
  };
}
function vs(e, t) {
  var n = Fn.lastIndex = Cn.lastIndex = 0, o, i, r, l = -1, a = [], s = [];
  for (e = e + "", t = t + ""; (o = Fn.exec(e)) && (i = Cn.exec(t)); )
    (r = i.index) > n && (r = t.slice(n, r), a[l] ? a[l] += r : a[++l] = r), (o = o[0]) === (i = i[0]) ? a[l] ? a[l] += i : a[++l] = i : (a[++l] = null, s.push({ i: l, x: Ue(o, i) })), n = Cn.lastIndex;
  return n < t.length && (r = t.slice(n), a[l] ? a[l] += r : a[++l] = r), a.length < 2 ? s[0] ? gs(s[0].x) : hs(t) : (t = s.length, function(u) {
    for (var c = 0, d; c < t; ++c)
      a[(d = s[c]).i] = d.x(u);
    return a.join("");
  });
}
var Do = 180 / Math.PI, Gn = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function Hi(e, t, n, o, i, r) {
  var l, a, s;
  return (l = Math.sqrt(e * e + t * t)) && (e /= l, t /= l), (s = e * n + t * o) && (n -= e * s, o -= t * s), (a = Math.sqrt(n * n + o * o)) && (n /= a, o /= a, s /= a), e * o < t * n && (e = -e, t = -t, s = -s, l = -l), {
    translateX: i,
    translateY: r,
    rotate: Math.atan2(t, e) * Do,
    skewX: Math.atan(s) * Do,
    scaleX: l,
    scaleY: a
  };
}
var Gt;
function ps(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Gn : Hi(t.a, t.b, t.c, t.d, t.e, t.f);
}
function ms(e) {
  return e == null || (Gt || (Gt = document.createElementNS("http://www.w3.org/2000/svg", "g")), Gt.setAttribute("transform", e), !(e = Gt.transform.baseVal.consolidate())) ? Gn : (e = e.matrix, Hi(e.a, e.b, e.c, e.d, e.e, e.f));
}
function Li(e, t, n, o) {
  function i(u) {
    return u.length ? u.pop() + " " : "";
  }
  function r(u, c, d, h, p, N) {
    if (u !== d || c !== h) {
      var f = p.push("translate(", null, t, null, n);
      N.push({ i: f - 4, x: Ue(u, d) }, { i: f - 2, x: Ue(c, h) });
    } else
      (d || h) && p.push("translate(" + d + t + h + n);
  }
  function l(u, c, d, h) {
    u !== c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), h.push({ i: d.push(i(d) + "rotate(", null, o) - 2, x: Ue(u, c) })) : c && d.push(i(d) + "rotate(" + c + o);
  }
  function a(u, c, d, h) {
    u !== c ? h.push({ i: d.push(i(d) + "skewX(", null, o) - 2, x: Ue(u, c) }) : c && d.push(i(d) + "skewX(" + c + o);
  }
  function s(u, c, d, h, p, N) {
    if (u !== d || c !== h) {
      var f = p.push(i(p) + "scale(", null, ",", null, ")");
      N.push({ i: f - 4, x: Ue(u, d) }, { i: f - 2, x: Ue(c, h) });
    } else
      (d !== 1 || h !== 1) && p.push(i(p) + "scale(" + d + "," + h + ")");
  }
  return function(u, c) {
    var d = [], h = [];
    return u = e(u), c = e(c), r(u.translateX, u.translateY, c.translateX, c.translateY, d, h), l(u.rotate, c.rotate, d, h), a(u.skewX, c.skewX, d, h), s(u.scaleX, u.scaleY, c.scaleX, c.scaleY, d, h), u = c = null, function(p) {
      for (var N = -1, f = h.length, g; ++N < f; )
        d[(g = h[N]).i] = g.x(p);
      return d.join("");
    };
  };
}
var ys = Li(ps, "px, ", "px)", "deg)"), xs = Li(ms, ", ", ")", ")"), ws = 1e-12;
function zo(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function _s(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function bs(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const Es = function e(t, n, o) {
  function i(r, l) {
    var a = r[0], s = r[1], u = r[2], c = l[0], d = l[1], h = l[2], p = c - a, N = d - s, f = p * p + N * N, g, _;
    if (f < ws)
      _ = Math.log(h / u) / t, g = function(D) {
        return [
          a + D * p,
          s + D * N,
          u * Math.exp(t * D * _)
        ];
      };
    else {
      var v = Math.sqrt(f), b = (h * h - u * u + o * f) / (2 * u * n * v), y = (h * h - u * u - o * f) / (2 * h * n * v), M = Math.log(Math.sqrt(b * b + 1) - b), x = Math.log(Math.sqrt(y * y + 1) - y);
      _ = (x - M) / t, g = function(D) {
        var V = D * _, H = zo(M), I = u / (n * v) * (H * bs(t * V + M) - _s(M));
        return [
          a + I * p,
          s + I * N,
          u * H / zo(t * V + M)
        ];
      };
    }
    return g.duration = _ * 1e3 * t / Math.SQRT2, g;
  }
  return i.rho = function(r) {
    var l = Math.max(1e-3, +r), a = l * l, s = a * a;
    return e(l, a, s);
  }, i;
}(Math.SQRT2, 2, 4);
var wt = 0, Nt = 0, Et = 0, Fi = 1e3, on, Ct, rn = 0, lt = 0, gn = 0, Dt = typeof performance == "object" && performance.now ? performance : Date, Gi = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function ro() {
  return lt || (Gi(Ss), lt = Dt.now() + gn);
}
function Ss() {
  lt = 0;
}
function ln() {
  this._call = this._time = this._next = null;
}
ln.prototype = Yi.prototype = {
  constructor: ln,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? ro() : +n) + (t == null ? 0 : +t), !this._next && Ct !== this && (Ct ? Ct._next = this : on = this, Ct = this), this._call = e, this._time = n, Yn();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Yn());
  }
};
function Yi(e, t, n) {
  var o = new ln();
  return o.restart(e, t, n), o;
}
function Ns() {
  ro(), ++wt;
  for (var e = on, t; e; )
    (t = lt - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --wt;
}
function Bo() {
  lt = (rn = Dt.now()) + gn, wt = Nt = 0;
  try {
    Ns();
  } finally {
    wt = 0, Ms(), lt = 0;
  }
}
function Cs() {
  var e = Dt.now(), t = e - rn;
  t > Fi && (gn -= t, rn = e);
}
function Ms() {
  for (var e, t = on, n, o = 1 / 0; t; )
    t._call ? (o > t._time && (o = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : on = n);
  Ct = e, Yn(o);
}
function Yn(e) {
  if (!wt) {
    Nt && (Nt = clearTimeout(Nt));
    var t = e - lt;
    t > 24 ? (e < 1 / 0 && (Nt = setTimeout(Bo, e - Dt.now() - gn)), Et && (Et = clearInterval(Et))) : (Et || (rn = Dt.now(), Et = setInterval(Cs, Fi)), wt = 1, Gi(Bo));
  }
}
function Ro(e, t, n) {
  var o = new ln();
  return t = t == null ? 0 : +t, o.restart((i) => {
    o.stop(), e(i + t);
  }, t, n), o;
}
var ks = fn("start", "end", "cancel", "interrupt"), $s = [], Xi = 0, Vo = 1, Xn = 2, qt = 3, Ho = 4, Un = 5, Kt = 6;
function vn(e, t, n, o, i, r) {
  var l = e.__transition;
  if (!l)
    e.__transition = {};
  else if (n in l)
    return;
  Ts(e, n, {
    name: t,
    index: o,
    // For context during callback.
    group: i,
    // For context during callback.
    on: ks,
    tween: $s,
    time: r.time,
    delay: r.delay,
    duration: r.duration,
    ease: r.ease,
    timer: null,
    state: Xi
  });
}
function lo(e, t) {
  var n = Pe(e, t);
  if (n.state > Xi)
    throw new Error("too late; already scheduled");
  return n;
}
function Re(e, t) {
  var n = Pe(e, t);
  if (n.state > qt)
    throw new Error("too late; already running");
  return n;
}
function Pe(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t]))
    throw new Error("transition not found");
  return n;
}
function Ts(e, t, n) {
  var o = e.__transition, i;
  o[t] = n, n.timer = Yi(r, 0, n.time);
  function r(u) {
    n.state = Vo, n.timer.restart(l, n.delay, n.time), n.delay <= u && l(u - n.delay);
  }
  function l(u) {
    var c, d, h, p;
    if (n.state !== Vo)
      return s();
    for (c in o)
      if (p = o[c], p.name === n.name) {
        if (p.state === qt)
          return Ro(l);
        p.state === Ho ? (p.state = Kt, p.timer.stop(), p.on.call("interrupt", e, e.__data__, p.index, p.group), delete o[c]) : +c < t && (p.state = Kt, p.timer.stop(), p.on.call("cancel", e, e.__data__, p.index, p.group), delete o[c]);
      }
    if (Ro(function() {
      n.state === qt && (n.state = Ho, n.timer.restart(a, n.delay, n.time), a(u));
    }), n.state = Xn, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Xn) {
      for (n.state = qt, i = new Array(h = n.tween.length), c = 0, d = -1; c < h; ++c)
        (p = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (i[++d] = p);
      i.length = d + 1;
    }
  }
  function a(u) {
    for (var c = u < n.duration ? n.ease.call(null, u / n.duration) : (n.timer.restart(s), n.state = Un, 1), d = -1, h = i.length; ++d < h; )
      i[d].call(e, c);
    n.state === Un && (n.on.call("end", e, e.__data__, n.index, n.group), s());
  }
  function s() {
    n.state = Kt, n.timer.stop(), delete o[t];
    for (var u in o)
      return;
    delete e.__transition;
  }
}
function jt(e, t) {
  var n = e.__transition, o, i, r = !0, l;
  if (n) {
    t = t == null ? null : t + "";
    for (l in n) {
      if ((o = n[l]).name !== t) {
        r = !1;
        continue;
      }
      i = o.state > Xn && o.state < Un, o.state = Kt, o.timer.stop(), o.on.call(i ? "interrupt" : "cancel", e, e.__data__, o.index, o.group), delete n[l];
    }
    r && delete e.__transition;
  }
}
function Ps(e) {
  return this.each(function() {
    jt(this, e);
  });
}
function Os(e, t) {
  var n, o;
  return function() {
    var i = Re(this, e), r = i.tween;
    if (r !== n) {
      o = n = r;
      for (var l = 0, a = o.length; l < a; ++l)
        if (o[l].name === t) {
          o = o.slice(), o.splice(l, 1);
          break;
        }
    }
    i.tween = o;
  };
}
function Is(e, t, n) {
  var o, i;
  if (typeof n != "function")
    throw new Error();
  return function() {
    var r = Re(this, e), l = r.tween;
    if (l !== o) {
      i = (o = l).slice();
      for (var a = { name: t, value: n }, s = 0, u = i.length; s < u; ++s)
        if (i[s].name === t) {
          i[s] = a;
          break;
        }
      s === u && i.push(a);
    }
    r.tween = i;
  };
}
function As(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var o = Pe(this.node(), n).tween, i = 0, r = o.length, l; i < r; ++i)
      if ((l = o[i]).name === e)
        return l.value;
    return null;
  }
  return this.each((t == null ? Os : Is)(n, e, t));
}
function ao(e, t, n) {
  var o = e._id;
  return e.each(function() {
    var i = Re(this, o);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return Pe(i, o).value[t];
  };
}
function Ui(e, t) {
  var n;
  return (typeof t == "number" ? Ue : t instanceof At ? Ao : (n = At(t)) ? (t = n, Ao) : vs)(e, t);
}
function Ds(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function zs(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Bs(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var l = this.getAttribute(e);
    return l === i ? null : l === o ? r : r = t(o = l, n);
  };
}
function Rs(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var l = this.getAttributeNS(e.space, e.local);
    return l === i ? null : l === o ? r : r = t(o = l, n);
  };
}
function Vs(e, t, n) {
  var o, i, r;
  return function() {
    var l, a = n(this), s;
    return a == null ? void this.removeAttribute(e) : (l = this.getAttribute(e), s = a + "", l === s ? null : l === o && s === i ? r : (i = s, r = t(o = l, a)));
  };
}
function Hs(e, t, n) {
  var o, i, r;
  return function() {
    var l, a = n(this), s;
    return a == null ? void this.removeAttributeNS(e.space, e.local) : (l = this.getAttributeNS(e.space, e.local), s = a + "", l === s ? null : l === o && s === i ? r : (i = s, r = t(o = l, a)));
  };
}
function Ls(e, t) {
  var n = hn(e), o = n === "transform" ? xs : Ui;
  return this.attrTween(e, typeof t == "function" ? (n.local ? Hs : Vs)(n, o, ao(this, "attr." + e, t)) : t == null ? (n.local ? zs : Ds)(n) : (n.local ? Rs : Bs)(n, o, t));
}
function Fs(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function Gs(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function Ys(e, t) {
  var n, o;
  function i() {
    var r = t.apply(this, arguments);
    return r !== o && (n = (o = r) && Gs(e, r)), n;
  }
  return i._value = t, i;
}
function Xs(e, t) {
  var n, o;
  function i() {
    var r = t.apply(this, arguments);
    return r !== o && (n = (o = r) && Fs(e, r)), n;
  }
  return i._value = t, i;
}
function Us(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  var o = hn(e);
  return this.tween(n, (o.local ? Ys : Xs)(o, t));
}
function Zs(e, t) {
  return function() {
    lo(this, e).delay = +t.apply(this, arguments);
  };
}
function Ws(e, t) {
  return t = +t, function() {
    lo(this, e).delay = t;
  };
}
function qs(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Zs : Ws)(t, e)) : Pe(this.node(), t).delay;
}
function Ks(e, t) {
  return function() {
    Re(this, e).duration = +t.apply(this, arguments);
  };
}
function js(e, t) {
  return t = +t, function() {
    Re(this, e).duration = t;
  };
}
function Js(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Ks : js)(t, e)) : Pe(this.node(), t).duration;
}
function Qs(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    Re(this, e).ease = t;
  };
}
function eu(e) {
  var t = this._id;
  return arguments.length ? this.each(Qs(t, e)) : Pe(this.node(), t).ease;
}
function tu(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function")
      throw new Error();
    Re(this, e).ease = n;
  };
}
function nu(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(tu(this._id, e));
}
function ou(e) {
  typeof e != "function" && (e = Si(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], l = r.length, a = o[i] = [], s, u = 0; u < l; ++u)
      (s = r[u]) && e.call(s, s.__data__, u, r) && a.push(s);
  return new Ge(o, this._parents, this._name, this._id);
}
function iu(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, n = e._groups, o = t.length, i = n.length, r = Math.min(o, i), l = new Array(o), a = 0; a < r; ++a)
    for (var s = t[a], u = n[a], c = s.length, d = l[a] = new Array(c), h, p = 0; p < c; ++p)
      (h = s[p] || u[p]) && (d[p] = h);
  for (; a < o; ++a)
    l[a] = t[a];
  return new Ge(l, this._parents, this._name, this._id);
}
function ru(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function lu(e, t, n) {
  var o, i, r = ru(t) ? lo : Re;
  return function() {
    var l = r(this, e), a = l.on;
    a !== o && (i = (o = a).copy()).on(t, n), l.on = i;
  };
}
function au(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Pe(this.node(), n).on.on(e) : this.each(lu(n, e, t));
}
function su(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition)
      if (+n !== e)
        return;
    t && t.removeChild(this);
  };
}
function uu() {
  return this.on("end.remove", su(this._id));
}
function cu(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = no(e));
  for (var o = this._groups, i = o.length, r = new Array(i), l = 0; l < i; ++l)
    for (var a = o[l], s = a.length, u = r[l] = new Array(s), c, d, h = 0; h < s; ++h)
      (c = a[h]) && (d = e.call(c, c.__data__, h, a)) && ("__data__" in c && (d.__data__ = c.__data__), u[h] = d, vn(u[h], t, n, h, u, Pe(c, n)));
  return new Ge(r, this._parents, t, n);
}
function du(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Ei(e));
  for (var o = this._groups, i = o.length, r = [], l = [], a = 0; a < i; ++a)
    for (var s = o[a], u = s.length, c, d = 0; d < u; ++d)
      if (c = s[d]) {
        for (var h = e.call(c, c.__data__, d, s), p, N = Pe(c, n), f = 0, g = h.length; f < g; ++f)
          (p = h[f]) && vn(p, t, n, f, h, N);
        r.push(h), l.push(c);
      }
  return new Ge(r, l, t, n);
}
var fu = Rt.prototype.constructor;
function hu() {
  return new fu(this._groups, this._parents);
}
function gu(e, t) {
  var n, o, i;
  return function() {
    var r = xt(this, e), l = (this.style.removeProperty(e), xt(this, e));
    return r === l ? null : r === n && l === o ? i : i = t(n = r, o = l);
  };
}
function Zi(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function vu(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var l = xt(this, e);
    return l === i ? null : l === o ? r : r = t(o = l, n);
  };
}
function pu(e, t, n) {
  var o, i, r;
  return function() {
    var l = xt(this, e), a = n(this), s = a + "";
    return a == null && (s = a = (this.style.removeProperty(e), xt(this, e))), l === s ? null : l === o && s === i ? r : (i = s, r = t(o = l, a));
  };
}
function mu(e, t) {
  var n, o, i, r = "style." + t, l = "end." + r, a;
  return function() {
    var s = Re(this, e), u = s.on, c = s.value[r] == null ? a || (a = Zi(t)) : void 0;
    (u !== n || i !== c) && (o = (n = u).copy()).on(l, i = c), s.on = o;
  };
}
function yu(e, t, n) {
  var o = (e += "") == "transform" ? ys : Ui;
  return t == null ? this.styleTween(e, gu(e, o)).on("end.style." + e, Zi(e)) : typeof t == "function" ? this.styleTween(e, pu(e, o, ao(this, "style." + e, t))).each(mu(this._id, e)) : this.styleTween(e, vu(e, o, t), n).on("end.style." + e, null);
}
function xu(e, t, n) {
  return function(o) {
    this.style.setProperty(e, t.call(this, o), n);
  };
}
function wu(e, t, n) {
  var o, i;
  function r() {
    var l = t.apply(this, arguments);
    return l !== i && (o = (i = l) && xu(e, l, n)), o;
  }
  return r._value = t, r;
}
function _u(e, t, n) {
  var o = "style." + (e += "");
  if (arguments.length < 2)
    return (o = this.tween(o)) && o._value;
  if (t == null)
    return this.tween(o, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(o, wu(e, t, n ?? ""));
}
function bu(e) {
  return function() {
    this.textContent = e;
  };
}
function Eu(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function Su(e) {
  return this.tween("text", typeof e == "function" ? Eu(ao(this, "text", e)) : bu(e == null ? "" : e + ""));
}
function Nu(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function Cu(e) {
  var t, n;
  function o() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && Nu(i)), t;
  }
  return o._value = e, o;
}
function Mu(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, Cu(e));
}
function ku() {
  for (var e = this._name, t = this._id, n = Wi(), o = this._groups, i = o.length, r = 0; r < i; ++r)
    for (var l = o[r], a = l.length, s, u = 0; u < a; ++u)
      if (s = l[u]) {
        var c = Pe(s, t);
        vn(s, e, n, u, l, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new Ge(o, this._parents, e, n);
}
function $u() {
  var e, t, n = this, o = n._id, i = n.size();
  return new Promise(function(r, l) {
    var a = { value: l }, s = { value: function() {
      --i === 0 && r();
    } };
    n.each(function() {
      var u = Re(this, o), c = u.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(s)), u.on = t;
    }), i === 0 && r();
  });
}
var Tu = 0;
function Ge(e, t, n, o) {
  this._groups = e, this._parents = t, this._name = n, this._id = o;
}
function Wi() {
  return ++Tu;
}
var Ve = Rt.prototype;
Ge.prototype = {
  constructor: Ge,
  select: cu,
  selectAll: du,
  selectChild: Ve.selectChild,
  selectChildren: Ve.selectChildren,
  filter: ou,
  merge: iu,
  selection: hu,
  transition: ku,
  call: Ve.call,
  nodes: Ve.nodes,
  node: Ve.node,
  size: Ve.size,
  empty: Ve.empty,
  each: Ve.each,
  on: au,
  attr: Ls,
  attrTween: Us,
  style: yu,
  styleTween: _u,
  text: Su,
  textTween: Mu,
  remove: uu,
  tween: As,
  delay: qs,
  duration: Js,
  ease: eu,
  easeVarying: nu,
  end: $u,
  [Symbol.iterator]: Ve[Symbol.iterator]
};
function Pu(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Ou = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Pu
};
function Iu(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function Au(e) {
  var t, n;
  e instanceof Ge ? (t = e._id, e = e._name) : (t = Wi(), (n = Ou).time = ro(), e = e == null ? null : e + "");
  for (var o = this._groups, i = o.length, r = 0; r < i; ++r)
    for (var l = o[r], a = l.length, s, u = 0; u < a; ++u)
      (s = l[u]) && vn(s, e, t, u, l, n || Iu(s, t));
  return new Ge(o, this._parents, e, t);
}
Rt.prototype.interrupt = Ps;
Rt.prototype.transition = Au;
const Yt = (e) => () => e;
function Du(e, {
  sourceEvent: t,
  target: n,
  transform: o,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: o, enumerable: !0, configurable: !0 },
    _: { value: i }
  });
}
function Le(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
Le.prototype = {
  constructor: Le,
  scale: function(e) {
    return e === 1 ? this : new Le(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new Le(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var _t = new Le(1, 0, 0);
Le.prototype;
function Mn(e) {
  e.stopImmediatePropagation();
}
function St(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function zu(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function Bu() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function Lo() {
  return this.__zoom || _t;
}
function Ru(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function Vu() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Hu(e, t, n) {
  var o = e.invertX(t[0][0]) - n[0][0], i = e.invertX(t[1][0]) - n[1][0], r = e.invertY(t[0][1]) - n[0][1], l = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    i > o ? (o + i) / 2 : Math.min(0, o) || Math.max(0, i),
    l > r ? (r + l) / 2 : Math.min(0, r) || Math.max(0, l)
  );
}
function Lu() {
  var e = zu, t = Bu, n = Hu, o = Ru, i = Vu, r = [0, 1 / 0], l = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], a = 250, s = Es, u = fn("start", "zoom", "end"), c, d, h, p = 500, N = 150, f = 0, g = 10;
  function _(m) {
    m.property("__zoom", Lo).on("wheel.zoom", V, { passive: !1 }).on("mousedown.zoom", H).on("dblclick.zoom", I).filter(i).on("touchstart.zoom", Z).on("touchmove.zoom", ee).on("touchend.zoom touchcancel.zoom", X).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  _.transform = function(m, k, E, O) {
    var z = m.selection ? m.selection() : m;
    z.property("__zoom", Lo), m !== z ? M(m, k, E, O) : z.interrupt().each(function() {
      x(this, arguments).event(O).start().zoom(null, typeof k == "function" ? k.apply(this, arguments) : k).end();
    });
  }, _.scaleBy = function(m, k, E, O) {
    _.scaleTo(m, function() {
      var z = this.__zoom.k, G = typeof k == "function" ? k.apply(this, arguments) : k;
      return z * G;
    }, E, O);
  }, _.scaleTo = function(m, k, E, O) {
    _.transform(m, function() {
      var z = t.apply(this, arguments), G = this.__zoom, P = E == null ? y(z) : typeof E == "function" ? E.apply(this, arguments) : E, U = G.invert(P), K = typeof k == "function" ? k.apply(this, arguments) : k;
      return n(b(v(G, K), P, U), z, l);
    }, E, O);
  }, _.translateBy = function(m, k, E, O) {
    _.transform(m, function() {
      return n(this.__zoom.translate(
        typeof k == "function" ? k.apply(this, arguments) : k,
        typeof E == "function" ? E.apply(this, arguments) : E
      ), t.apply(this, arguments), l);
    }, null, O);
  }, _.translateTo = function(m, k, E, O, z) {
    _.transform(m, function() {
      var G = t.apply(this, arguments), P = this.__zoom, U = O == null ? y(G) : typeof O == "function" ? O.apply(this, arguments) : O;
      return n(_t.translate(U[0], U[1]).scale(P.k).translate(
        typeof k == "function" ? -k.apply(this, arguments) : -k,
        typeof E == "function" ? -E.apply(this, arguments) : -E
      ), G, l);
    }, O, z);
  };
  function v(m, k) {
    return k = Math.max(r[0], Math.min(r[1], k)), k === m.k ? m : new Le(k, m.x, m.y);
  }
  function b(m, k, E) {
    var O = k[0] - E[0] * m.k, z = k[1] - E[1] * m.k;
    return O === m.x && z === m.y ? m : new Le(m.k, O, z);
  }
  function y(m) {
    return [(+m[0][0] + +m[1][0]) / 2, (+m[0][1] + +m[1][1]) / 2];
  }
  function M(m, k, E, O) {
    m.on("start.zoom", function() {
      x(this, arguments).event(O).start();
    }).on("interrupt.zoom end.zoom", function() {
      x(this, arguments).event(O).end();
    }).tween("zoom", function() {
      var z = this, G = arguments, P = x(z, G).event(O), U = t.apply(z, G), K = E == null ? y(U) : typeof E == "function" ? E.apply(z, G) : E, L = Math.max(U[1][0] - U[0][0], U[1][1] - U[0][1]), j = z.__zoom, $ = typeof k == "function" ? k.apply(z, G) : k, te = s(j.invert(K).concat(L / j.k), $.invert(K).concat(L / $.k));
      return function(Q) {
        if (Q === 1)
          Q = $;
        else {
          var oe = te(Q), ne = L / oe[2];
          Q = new Le(ne, K[0] - oe[0] * ne, K[1] - oe[1] * ne);
        }
        P.zoom(null, Q);
      };
    });
  }
  function x(m, k, E) {
    return !E && m.__zooming || new D(m, k);
  }
  function D(m, k) {
    this.that = m, this.args = k, this.active = 0, this.sourceEvent = null, this.extent = t.apply(m, k), this.taps = 0;
  }
  D.prototype = {
    event: function(m) {
      return m && (this.sourceEvent = m), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(m, k) {
      return this.mouse && m !== "mouse" && (this.mouse[1] = k.invert(this.mouse[0])), this.touch0 && m !== "touch" && (this.touch0[1] = k.invert(this.touch0[0])), this.touch1 && m !== "touch" && (this.touch1[1] = k.invert(this.touch1[0])), this.that.__zoom = k, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(m) {
      var k = ke(this.that).datum();
      u.call(
        m,
        this.that,
        new Du(m, {
          sourceEvent: this.sourceEvent,
          target: _,
          type: m,
          transform: this.that.__zoom,
          dispatch: u
        }),
        k
      );
    }
  };
  function V(m, ...k) {
    if (!e.apply(this, arguments))
      return;
    var E = x(this, k).event(m), O = this.__zoom, z = Math.max(r[0], Math.min(r[1], O.k * Math.pow(2, o.apply(this, arguments)))), G = Oe(m);
    if (E.wheel)
      (E.mouse[0][0] !== G[0] || E.mouse[0][1] !== G[1]) && (E.mouse[1] = O.invert(E.mouse[0] = G)), clearTimeout(E.wheel);
    else {
      if (O.k === z)
        return;
      E.mouse = [G, O.invert(G)], jt(this), E.start();
    }
    St(m), E.wheel = setTimeout(P, N), E.zoom("mouse", n(b(v(O, z), E.mouse[0], E.mouse[1]), E.extent, l));
    function P() {
      E.wheel = null, E.end();
    }
  }
  function H(m, ...k) {
    if (h || !e.apply(this, arguments))
      return;
    var E = m.currentTarget, O = x(this, k, !0).event(m), z = ke(m.view).on("mousemove.zoom", K, !0).on("mouseup.zoom", L, !0), G = Oe(m, E), P = m.clientX, U = m.clientY;
    Ai(m.view), Mn(m), O.mouse = [G, this.__zoom.invert(G)], jt(this), O.start();
    function K(j) {
      if (St(j), !O.moved) {
        var $ = j.clientX - P, te = j.clientY - U;
        O.moved = $ * $ + te * te > f;
      }
      O.event(j).zoom("mouse", n(b(O.that.__zoom, O.mouse[0] = Oe(j, E), O.mouse[1]), O.extent, l));
    }
    function L(j) {
      z.on("mousemove.zoom mouseup.zoom", null), Di(j.view, O.moved), St(j), O.event(j).end();
    }
  }
  function I(m, ...k) {
    if (e.apply(this, arguments)) {
      var E = this.__zoom, O = Oe(m.changedTouches ? m.changedTouches[0] : m, this), z = E.invert(O), G = E.k * (m.shiftKey ? 0.5 : 2), P = n(b(v(E, G), O, z), t.apply(this, k), l);
      St(m), a > 0 ? ke(this).transition().duration(a).call(M, P, O, m) : ke(this).call(_.transform, P, O, m);
    }
  }
  function Z(m, ...k) {
    if (e.apply(this, arguments)) {
      var E = m.touches, O = E.length, z = x(this, k, m.changedTouches.length === O).event(m), G, P, U, K;
      for (Mn(m), P = 0; P < O; ++P)
        U = E[P], K = Oe(U, this), K = [K, this.__zoom.invert(K), U.identifier], z.touch0 ? !z.touch1 && z.touch0[2] !== K[2] && (z.touch1 = K, z.taps = 0) : (z.touch0 = K, G = !0, z.taps = 1 + !!c);
      c && (c = clearTimeout(c)), G && (z.taps < 2 && (d = K[0], c = setTimeout(function() {
        c = null;
      }, p)), jt(this), z.start());
    }
  }
  function ee(m, ...k) {
    if (this.__zooming) {
      var E = x(this, k).event(m), O = m.changedTouches, z = O.length, G, P, U, K;
      for (St(m), G = 0; G < z; ++G)
        P = O[G], U = Oe(P, this), E.touch0 && E.touch0[2] === P.identifier ? E.touch0[0] = U : E.touch1 && E.touch1[2] === P.identifier && (E.touch1[0] = U);
      if (P = E.that.__zoom, E.touch1) {
        var L = E.touch0[0], j = E.touch0[1], $ = E.touch1[0], te = E.touch1[1], Q = (Q = $[0] - L[0]) * Q + (Q = $[1] - L[1]) * Q, oe = (oe = te[0] - j[0]) * oe + (oe = te[1] - j[1]) * oe;
        P = v(P, Math.sqrt(Q / oe)), U = [(L[0] + $[0]) / 2, (L[1] + $[1]) / 2], K = [(j[0] + te[0]) / 2, (j[1] + te[1]) / 2];
      } else if (E.touch0)
        U = E.touch0[0], K = E.touch0[1];
      else
        return;
      E.zoom("touch", n(b(P, U, K), E.extent, l));
    }
  }
  function X(m, ...k) {
    if (this.__zooming) {
      var E = x(this, k).event(m), O = m.changedTouches, z = O.length, G, P;
      for (Mn(m), h && clearTimeout(h), h = setTimeout(function() {
        h = null;
      }, p), G = 0; G < z; ++G)
        P = O[G], E.touch0 && E.touch0[2] === P.identifier ? delete E.touch0 : E.touch1 && E.touch1[2] === P.identifier && delete E.touch1;
      if (E.touch1 && !E.touch0 && (E.touch0 = E.touch1, delete E.touch1), E.touch0)
        E.touch0[1] = this.__zoom.invert(E.touch0[0]);
      else if (E.end(), E.taps === 2 && (P = Oe(P, this), Math.hypot(d[0] - P[0], d[1] - P[1]) < g)) {
        var U = ke(this).on("dblclick.zoom");
        U && U.apply(this, arguments);
      }
    }
  }
  return _.wheelDelta = function(m) {
    return arguments.length ? (o = typeof m == "function" ? m : Yt(+m), _) : o;
  }, _.filter = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Yt(!!m), _) : e;
  }, _.touchable = function(m) {
    return arguments.length ? (i = typeof m == "function" ? m : Yt(!!m), _) : i;
  }, _.extent = function(m) {
    return arguments.length ? (t = typeof m == "function" ? m : Yt([[+m[0][0], +m[0][1]], [+m[1][0], +m[1][1]]]), _) : t;
  }, _.scaleExtent = function(m) {
    return arguments.length ? (r[0] = +m[0], r[1] = +m[1], _) : [r[0], r[1]];
  }, _.translateExtent = function(m) {
    return arguments.length ? (l[0][0] = +m[0][0], l[1][0] = +m[1][0], l[0][1] = +m[0][1], l[1][1] = +m[1][1], _) : [[l[0][0], l[0][1]], [l[1][0], l[1][1]]];
  }, _.constrain = function(m) {
    return arguments.length ? (n = m, _) : n;
  }, _.duration = function(m) {
    return arguments.length ? (a = +m, _) : a;
  }, _.interpolate = function(m) {
    return arguments.length ? (s = m, _) : s;
  }, _.on = function() {
    var m = u.on.apply(u, arguments);
    return m === u ? _ : m;
  }, _.clickDistance = function(m) {
    return arguments.length ? (f = (m = +m) * m, _) : Math.sqrt(f);
  }, _.tapDistance = function(m) {
    return arguments.length ? (g = +m, _) : g;
  }, _;
}
var q = /* @__PURE__ */ ((e) => (e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom", e))(q || {}), so = /* @__PURE__ */ ((e) => (e.Partial = "partial", e.Full = "full", e))(so || {}), ct = /* @__PURE__ */ ((e) => (e.Bezier = "default", e.SimpleBezier = "simple-bezier", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e))(ct || {}), at = /* @__PURE__ */ ((e) => (e.Strict = "strict", e.Loose = "loose", e))(at || {}), Zn = /* @__PURE__ */ ((e) => (e.Arrow = "arrow", e.ArrowClosed = "arrowclosed", e))(Zn || {}), kt = /* @__PURE__ */ ((e) => (e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal", e))(kt || {}), Fu = /* @__PURE__ */ ((e) => (e.TopLeft = "top-left", e.TopCenter = "top-center", e.TopRight = "top-right", e.BottomLeft = "bottom-left", e.BottomCenter = "bottom-center", e.BottomRight = "bottom-right", e))(Fu || {});
const qi = "vue-flow__node-desc", Ki = "vue-flow__edge-desc", Gu = "vue-flow__aria-live", ji = ["Enter", " ", "Escape"], pt = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
};
function Fo(e) {
  return {
    ...e.computedPosition || { x: 0, y: 0 },
    width: e.dimensions.width || 0,
    height: e.dimensions.height || 0
  };
}
function Wn(e, t) {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), o = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * o);
}
function pn(e) {
  return {
    width: e.offsetWidth,
    height: e.offsetHeight
  };
}
function st(e, t = 0, n = 1) {
  return Math.min(Math.max(e, t), n);
}
function Ji(e, t) {
  return {
    x: st(e.x, t[0][0], t[1][0]),
    y: st(e.y, t[0][1], t[1][1])
  };
}
function Go(e) {
  const t = e.getRootNode(), n = vo();
  return "elementFromPoint" in t ? t : n.document;
}
function Be(e) {
  return e && typeof e == "object" && "id" in e && "source" in e && "target" in e;
}
function Yu(e) {
  return Be(e) && "sourceNode" in e && "targetNode" in e;
}
function nt(e) {
  return e && typeof e == "object" && "id" in e && "position" in e && !Be(e);
}
function dt(e) {
  return nt(e) && "computedPosition" in e;
}
function Xu(e) {
  return !!e.width && !!e.height && !!e.x && !!e.y;
}
function Uu(e, t = {}) {
  let n = t;
  return dt(e) || (n = {
    type: e.type ?? t.type ?? "default",
    dimensions: ht({
      width: 0,
      height: 0
    }),
    handleBounds: {
      source: [],
      target: []
    },
    computedPosition: ht({
      z: 0,
      ...e.position
    }),
    draggable: void 0,
    selectable: void 0,
    connectable: void 0,
    focusable: void 0,
    selected: !1,
    dragging: !1,
    resizing: !1,
    initialized: !1,
    ...t,
    data: he(e.data) ? e.data : {},
    events: ht(he(e.events) ? e.events : {})
  }), Object.assign({}, n, e, { id: e.id.toString() });
}
function uo(e, t = {}) {
  const n = he(e.events) ? e.events : t.events && he(t.events) ? t.events : {}, o = he(e.data) ? e.data : t.data && he(t.data) ? t.data : {};
  return t = Yu(e) ? t : {
    ...t,
    sourceHandle: (e.sourceHandle ? e.sourceHandle.toString() : void 0) || t.sourceHandle,
    targetHandle: (e.targetHandle ? e.targetHandle.toString() : void 0) || t.targetHandle,
    type: e.type ?? t.type ?? "default",
    source: e.source.toString() || t.source,
    target: e.target.toString() || t.target,
    updatable: e.updatable ?? t.updatable,
    selectable: e.selectable ?? t.selectable,
    focusable: e.focusable ?? t.focusable,
    data: o,
    events: ht(n),
    label: (e.label && !Me(e.label) ? ht(e.label) : e.label) || t.label,
    interactionWidth: e.interactionWidth || t.interactionWidth
  }, Object.assign({}, t, e, { id: e.id.toString() });
}
function Qi(e, t, n, o) {
  const i = Me(e) ? e : e.id, r = /* @__PURE__ */ new Set(), l = o === "source" ? "target" : "source";
  return n.forEach((a) => {
    a[l] === i && r.add(a[o]);
  }), t.filter((a) => r.has(a.id));
}
function Zu(...e) {
  if (e.length === 3) {
    const [r, l, a] = e;
    return Qi(r, l, a, "target");
  }
  const [t, n] = e, o = Me(t) ? { id: t } : t;
  return n.filter((r) => Be(r) && r.source === o.id).map((r) => n.find((l) => nt(l) && l.id === r.target));
}
function Wu(...e) {
  if (e.length === 3) {
    const [r, l, a] = e;
    return Qi(r, l, a, "source");
  }
  const [t, n] = e, o = Me(t) ? { id: t } : t;
  return n.filter((r) => Be(r) && r.target === o.id).map((r) => n.find((l) => nt(l) && l.id === r.source));
}
function mn({ source: e, sourceHandle: t, target: n, targetHandle: o }) {
  return `vueflow__edge-${e}${t ?? ""}-${n}${o ?? ""}`;
}
function er(e, t) {
  return t.some(
    (n) => Be(n) && n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)
  );
}
function Hd(e, t, n) {
  if (!e.source || !e.target)
    return zt("Can't create edge. An edge needs a source and a target."), t;
  let o;
  return Be(e) ? o = { ...e } : o = {
    ...e,
    id: mn(e)
  }, o = uo(o, n), er(o, t) || t.push(o), t;
}
function Ld(e, t, n) {
  if (!t.source || !t.target)
    return zt("Can't create new edge. An edge needs a source and a target."), n;
  const o = n.find((r) => Be(r) && r.id === e.id);
  if (!o)
    return zt(`The old edge with id=${e.id} does not exist.`), n;
  const i = {
    ...e,
    id: mn(t),
    source: t.source,
    target: t.target,
    sourceHandle: t.sourceHandle,
    targetHandle: t.targetHandle
  };
  return n.splice(n.indexOf(o), 1, i), n.filter((r) => r.id !== e.id);
}
function tr({ x: e, y: t }, { x: n, y: o, zoom: i }) {
  return {
    x: e * i + n,
    y: t * i + o
  };
}
function qn({ x: e, y: t }, { x: n, y: o, zoom: i }, r, [l, a]) {
  const s = {
    x: (e - n) / i,
    y: (t - o) / i
  };
  return r ? {
    x: l * Math.round(s.x / l),
    y: a * Math.round(s.y / a)
  } : s;
}
function nr(e, t) {
  return {
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x2, t.x2),
    y2: Math.max(e.y2, t.y2)
  };
}
function an({ x: e, y: t, width: n, height: o }) {
  return {
    x: e,
    y: t,
    x2: e + n,
    y2: t + o
  };
}
function or({ x: e, y: t, x2: n, y2: o }) {
  return {
    x: e,
    y: t,
    width: n - e,
    height: o - t
  };
}
function Fd(e, t) {
  return or(nr(an(e), an(t)));
}
function ir(e) {
  const t = e.reduce(
    (n, { computedPosition: o = { x: 0, y: 0 }, dimensions: i = { width: 0, height: 0 } } = {}) => nr(
      n,
      an({
        ...o,
        ...i
      })
    ),
    { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }
  );
  return or(t);
}
function rr(e, t, { x: n, y: o, zoom: i } = { x: 0, y: 0, zoom: 1 }, r = !1, l = !1) {
  const a = {
    x: (t.x - n) / i,
    y: (t.y - o) / i,
    width: t.width / i,
    height: t.height / i
  };
  return e.filter((s) => {
    const { computedPosition: u = { x: 0, y: 0 }, dimensions: c = { width: 0, height: 0 }, selectable: d } = s;
    if (l && !d)
      return !1;
    const h = { ...u, width: c.width || 0, height: c.height || 0 }, p = Wn(a, h), N = typeof c.width > "u" || typeof c.height > "u" || c.width === 0 || c.height === 0, f = r && p > 0, g = c.width * c.height;
    return N || f || p >= g;
  });
}
function yn(e, t) {
  const n = /* @__PURE__ */ new Set();
  return Me(e) ? n.add(e) : e.length >= 1 && e.forEach((o) => n.add(o.id)), t.filter((o) => n.has(o.source) || n.has(o.target));
}
function Yo(e, t, n, o, i, r = 0.1, l = { x: 0, y: 0 }) {
  const a = t / (e.width * (1 + r)), s = n / (e.height * (1 + r)), u = Math.min(a, s), c = st(u, o, i), d = e.x + e.width / 2, h = e.y + e.height / 2, p = t / 2 - d * c + (l.x ?? 0), N = n / 2 - h * c + (l.y ?? 0);
  return { x: p, y: N, zoom: c };
}
function qu(e, t) {
  return {
    x: t.x + e.x,
    y: t.y + e.y,
    z: (e.z > t.z ? e.z : t.z) + 1
  };
}
function lr(e, t) {
  if (!e.parentNode)
    return !1;
  const n = t(e.parentNode);
  return n ? n.selected ? !0 : lr(n, t) : !1;
}
function Qe(e, t) {
  return typeof e > "u" ? "" : typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((o) => `${o}=${e[o]}`).join("&")}`;
}
function Xo(e, t, n) {
  return e < t ? st(Math.abs(e - t), 1, 50) / 50 : e > n ? -st(Math.abs(e - n), 1, 50) / 50 : 0;
}
function ar(e, t) {
  const n = Xo(e.x, 35, t.width - 35) * 20, o = Xo(e.y, 35, t.height - 35) * 20;
  return [n, o];
}
function kn(e, t) {
  if (t) {
    const n = e.position.x + e.dimensions.width - t.dimensions.width, o = e.position.y + e.dimensions.height - t.dimensions.height;
    if (n > 0 || o > 0 || e.position.x < 0 || e.position.y < 0) {
      let i = {};
      if (bt(t.style) ? i = { ...t.style(t) } : t.style && (i = { ...t.style }), i.width = i.width ?? `${t.dimensions.width}px`, i.height = i.height ?? `${t.dimensions.height}px`, n > 0)
        if (Me(i.width)) {
          const r = Number(i.width.replace("px", ""));
          i.width = `${r + n}px`;
        } else
          i.width += n;
      if (o > 0)
        if (Me(i.height)) {
          const r = Number(i.height.replace("px", ""));
          i.height = `${r + o}px`;
        } else
          i.height += o;
      if (e.position.x < 0) {
        const r = Math.abs(e.position.x);
        if (t.position.x = t.position.x - r, Me(i.width)) {
          const l = Number(i.width.replace("px", ""));
          i.width = `${l + r}px`;
        } else
          i.width += r;
        e.position.x = 0;
      }
      if (e.position.y < 0) {
        const r = Math.abs(e.position.y);
        if (t.position.y = t.position.y - r, Me(i.height)) {
          const l = Number(i.height.replace("px", ""));
          i.height = `${l + r}px`;
        } else
          i.height += r;
        e.position.y = 0;
      }
      t.dimensions.width = Number(i.width.toString().replace("px", "")), t.dimensions.height = Number(i.height.toString().replace("px", "")), bt(t.style) ? t.style = (r) => {
        const l = t.style;
        return {
          ...l(r),
          ...i
        };
      } : t.style = {
        ...t.style,
        ...i
      };
    }
  }
}
function sn(e, t) {
  e.filter((i) => i.type === "add" || i.type === "remove").forEach((i) => {
    if (i.type === "add")
      t.findIndex((l) => l.id === i.item.id) === -1 && t.push(i.item);
    else if (i.type === "remove") {
      const r = t.findIndex((l) => l.id === i.id);
      r !== -1 && t.splice(r, 1);
    }
  });
  const o = t.map((i) => i.id);
  return t.forEach((i) => {
    var l, a;
    const r = e.filter((s) => s.id === i.id);
    for (const s of r)
      switch (s.type) {
        case "select":
          i.selected = s.selected;
          break;
        case "position":
          if (dt(i) && (typeof s.position < "u" && (i.position = s.position), typeof s.dragging < "u" && (i.dragging = s.dragging), i.expandParent && i.parentNode)) {
            const u = t[o.indexOf(i.parentNode)];
            u && dt(u) && kn(i, u);
          }
          break;
        case "dimensions":
          if (dt(i)) {
            if (typeof s.dimensions < "u" && (i.dimensions = s.dimensions), typeof s.updateStyle < "u" && (i.style = {
              ...i.style || {},
              width: `${(l = s.dimensions) == null ? void 0 : l.width}px`,
              height: `${(a = s.dimensions) == null ? void 0 : a.height}px`
            }), typeof s.resizing < "u" && (i.resizing = s.resizing), i.expandParent && i.parentNode) {
              const u = t[o.indexOf(i.parentNode)];
              u && dt(u) && (u.initialized ? kn(i, u) : et(() => {
                kn(i, u);
              }));
            }
            i.initialized || (i.initialized = !0);
          }
          break;
      }
  }), t;
}
function Gd(e, t) {
  return sn(e, t);
}
function Yd(e, t) {
  return sn(e, t);
}
function He(e, t) {
  return {
    id: e,
    type: "select",
    selected: t
  };
}
function Uo(e) {
  return {
    item: e,
    type: "add"
  };
}
function Zo(e) {
  return {
    id: e,
    type: "remove"
  };
}
function Wo(e, t, n) {
  return {
    id: e,
    source: t,
    target: n,
    type: "remove"
  };
}
function $n(e, t) {
  return e.reduce(
    (n, o) => {
      let i = t.includes(o.id);
      he(o.selectable) && !o.selectable && (i = !1);
      const r = dt(o) ? "changedNodes" : "changedEdges";
      return !o.selected && i ? n[r].push(He(o.id, !0)) : o.selected && !i && n[r].push(He(o.id, !1)), n;
    },
    { changedNodes: [], changedEdges: [] }
  );
}
function R(e = () => {
}) {
  const t = /* @__PURE__ */ new Set(), n = () => t.size > 0;
  e && t.add(e);
  const o = (l) => {
    t.delete(l);
  };
  return {
    on: (l) => {
      t.has(e) && t.delete(e), t.add(l);
      const a = () => o(l);
      return Bt(a), {
        off: a
      };
    },
    off: o,
    trigger: (l) => Promise.all(Array.from(t).map((a) => a(l))),
    hasListeners: n
  };
}
function qo(e, t, n) {
  let o = e;
  do {
    if (o && o.matches(t))
      return !0;
    if (o === n)
      return !1;
    o = o.parentElement;
  } while (o);
  return !1;
}
function Ku(e, t, n, o, i) {
  return e.filter(
    (r) => (r.selected || r.id === i) && (!r.parentNode || !lr(r, o)) && (r.draggable || t && typeof r.draggable > "u")
  ).map(
    (r) => {
      var l, a;
      return ht({
        id: r.id,
        position: r.position || { x: 0, y: 0 },
        distance: {
          x: n.x - ((l = r.computedPosition) == null ? void 0 : l.x) || 0,
          y: n.y - ((a = r.computedPosition) == null ? void 0 : a.y) || 0
        },
        from: r.computedPosition,
        extent: r.extent,
        parentNode: r.parentNode,
        dimensions: r.dimensions,
        expandParent: r.expandParent
      });
    }
  );
}
function Tn({
  id: e,
  dragItems: t,
  findNode: n
}) {
  const o = t.reduce((i, r) => {
    const l = n(r.id);
    return l && i.push(l), i;
  }, []);
  return [e ? o.find((i) => i.id === e) : o[0], o];
}
function sr(e) {
  if (Array.isArray(e))
    switch (e.length) {
      case 1:
        return [e[0], e[0], e[0], e[0]];
      case 2:
        return [e[0], e[1], e[0], e[1]];
      case 3:
        return [e[0], e[1], e[2], e[1]];
      case 4:
        return e;
      default:
        return [0, 0, 0, 0];
    }
  return [e, e, e, e];
}
function ju(e, t, n) {
  const [o, i, r, l] = typeof e != "string" ? sr(e.padding) : [0, 0, 0, 0];
  return n && Ie(n.computedPosition.x) && Ie(n.computedPosition.y) && Ie(n.dimensions.width) && Ie(n.dimensions.height) ? [
    [n.computedPosition.x + l, n.computedPosition.y + o],
    [
      n.computedPosition.x + n.dimensions.width - i,
      n.computedPosition.y + n.dimensions.height - r
    ]
  ] : !1;
}
function Ju(e, t, n, o) {
  let i = e.extent || n;
  if ((i === "parent" || !Array.isArray(i) && (i == null ? void 0 : i.range) === "parent") && !e.expandParent)
    if (e.parentNode && o && e.dimensions.width && e.dimensions.height) {
      const r = ju(i, e, o);
      r && (i = r);
    } else
      t(new Ee(_e.NODE_EXTENT_INVALID, e.id)), i = n;
  else if (Array.isArray(i)) {
    const r = (o == null ? void 0 : o.computedPosition.x) || 0, l = (o == null ? void 0 : o.computedPosition.y) || 0;
    i = [
      [i[0][0] + r, i[0][1] + l],
      [i[1][0] + r, i[1][1] + l]
    ];
  } else if (i !== "parent" && (i != null && i.range) && Array.isArray(i.range)) {
    const [r, l, a, s] = sr(i.padding), u = (o == null ? void 0 : o.computedPosition.x) || 0, c = (o == null ? void 0 : o.computedPosition.y) || 0;
    i = [
      [i.range[0][0] + u + s, i.range[0][1] + c + r],
      [i.range[1][0] + u - l, i.range[1][1] + c - a]
    ];
  }
  return i === "parent" ? [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
  ] : i;
}
function Qu({ width: e, height: t }, n) {
  return [n[0], [n[1][0] - (e || 0), n[1][1] - (t || 0)]];
}
function co(e, t, n, o, i) {
  const r = Qu(e.dimensions, Ju(e, n, o, i)), l = Ji(t, r);
  return {
    position: {
      x: l.x - ((i == null ? void 0 : i.computedPosition.x) || 0),
      y: l.y - ((i == null ? void 0 : i.computedPosition.y) || 0)
    },
    computedPosition: l
  };
}
function Kn(e, t, n) {
  const o = ((n == null ? void 0 : n.x) ?? 0) + t.x, i = ((n == null ? void 0 : n.y) ?? 0) + t.y, r = (n == null ? void 0 : n.width) ?? t.width, l = (n == null ? void 0 : n.height) ?? t.height;
  switch (e) {
    case q.Top:
      return {
        x: o + r / 2,
        y: i
      };
    case q.Right:
      return {
        x: o + r,
        y: i + l / 2
      };
    case q.Bottom:
      return {
        x: o + r / 2,
        y: i + l
      };
    case q.Left:
      return {
        x: o,
        y: i + l / 2
      };
  }
}
function Ko(e = [], t) {
  return e.length ? !t || e.length === 1 ? e[0] : t && e.find((n) => n.id === t) || null : null;
}
function ec(e, t, n, o, i, r) {
  const l = Kn(
    n,
    {
      ...e.dimensions,
      ...e.computedPosition
    },
    t
  ), a = Kn(
    r,
    {
      ...o.dimensions,
      ...o.computedPosition
    },
    i
  );
  return {
    sourceX: l.x,
    sourceY: l.y,
    targetX: a.x,
    targetY: a.y
  };
}
function tc({
  sourcePos: e,
  targetPos: t,
  sourceWidth: n,
  sourceHeight: o,
  targetWidth: i,
  targetHeight: r,
  width: l,
  height: a,
  viewport: s
}) {
  const u = {
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x + n, t.x + i),
    y2: Math.max(e.y + o, t.y + r)
  };
  u.x === u.x2 && (u.x2 += 1), u.y === u.y2 && (u.y2 += 1);
  const c = an({
    x: (0 - s.x) / s.zoom,
    y: (0 - s.y) / s.zoom,
    width: l / s.zoom,
    height: a / s.zoom
  }), d = Math.max(0, Math.min(c.x2, u.x2) - Math.max(c.x, u.x)), h = Math.max(0, Math.min(c.y2, u.y2) - Math.max(c.y, u.y));
  return Math.ceil(d * h) > 0;
}
function nc(e, t, n = !1) {
  const o = Ie(e.zIndex);
  let i = o ? e.zIndex : 0;
  const r = t(e.source), l = t(e.target);
  return !r || !l ? 0 : (n && (i = o ? e.zIndex : Math.max(r.computedPosition.z || 0, l.computedPosition.z || 0)), i);
}
var _e = /* @__PURE__ */ ((e) => (e.MISSING_VIEWPORT_DIMENSIONS = "MISSING_VIEWPORT_DIMENSIONS", e.NODE_INVALID = "NODE_INVALID", e.NODE_NOT_FOUND = "NODE_NOT_FOUND", e.NODE_MISSING_PARENT = "NODE_MISSING_PARENT", e.NODE_TYPE_MISSING = "NODE_TYPE_MISSING", e.NODE_EXTENT_INVALID = "NODE_EXTENT_INVALID", e.EDGE_INVALID = "EDGE_INVALID", e.EDGE_NOT_FOUND = "EDGE_NOT_FOUND", e.EDGE_SOURCE_MISSING = "EDGE_SOURCE_MISSING", e.EDGE_TARGET_MISSING = "EDGE_TARGET_MISSING", e.EDGE_TYPE_MISSING = "EDGE_TYPE_MISSING", e.EDGE_SOURCE_TARGET_SAME = "EDGE_SOURCE_TARGET_SAME", e.EDGE_SOURCE_TARGET_MISSING = "EDGE_SOURCE_TARGET_MISSING", e.EDGE_ORPHANED = "EDGE_ORPHANED", e))(_e || {});
const Pn = {
  MISSING_VIEWPORT_DIMENSIONS: () => "The Vue Flow parent container needs a width and a height to render the graph",
  NODE_INVALID: (e) => `Node is invalid
Node: ${e}`,
  NODE_NOT_FOUND: (e) => `Node not found
Node: ${e}`,
  NODE_MISSING_PARENT: (e, t) => `Node is missing a parent
Node: ${e}
Parent: ${t}`,
  NODE_TYPE_MISSING: (e) => `Node type is missing
Type: ${e}`,
  NODE_EXTENT_INVALID: (e) => `Only child nodes can use a parent extent
Node: ${e}`,
  EDGE_INVALID: (e) => `An edge needs a source and a target
Edge: ${e}`,
  EDGE_SOURCE_MISSING: (e, t) => `Edge source is missing
Edge: ${e} 
Source: ${t}`,
  EDGE_TARGET_MISSING: (e, t) => `Edge target is missing
Edge: ${e} 
Target: ${t}`,
  EDGE_TYPE_MISSING: (e) => `Edge type is missing
Type: ${e}`,
  EDGE_SOURCE_TARGET_SAME: (e, t, n) => `Edge source and target are the same
Edge: ${e} 
Source: ${t} 
Target: ${n}`,
  EDGE_SOURCE_TARGET_MISSING: (e, t, n) => `Edge source or target is missing
Edge: ${e} 
Source: ${t} 
Target: ${n}`,
  EDGE_ORPHANED: (e) => `Edge was orphaned (suddenly missing source or target) and has been removed
Edge: ${e}`,
  EDGE_NOT_FOUND: (e) => `Edge not found
Edge: ${e}`
};
class Ee extends Error {
  constructor(t, ...n) {
    var o;
    super((o = Pn[t]) == null ? void 0 : o.call(Pn, ...n)), this.code = t;
  }
}
function fo(e) {
  return "clientX" in e;
}
function ot(e, t) {
  var r, l;
  const n = fo(e), o = n ? e.clientX : (r = e.touches) == null ? void 0 : r[0].clientX, i = n ? e.clientY : (l = e.touches) == null ? void 0 : l[0].clientY;
  return {
    x: o - ((t == null ? void 0 : t.left) ?? 0),
    y: i - ((t == null ? void 0 : t.top) ?? 0)
  };
}
function Me(e) {
  return typeof e == "string";
}
function bt(e) {
  return typeof e == "function";
}
function On(e) {
  return typeof e == "boolean";
}
function Ie(e) {
  return typeof e == "number";
}
const un = () => {
  var e;
  return typeof navigator < "u" && ((e = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : e.indexOf("Mac")) >= 0;
};
function ur() {
  return {
    handleDomNode: null,
    isValid: !1,
    connection: { source: "", target: "", sourceHandle: null, targetHandle: null },
    endHandle: null
  };
}
function In(e) {
  e == null || e.classList.remove("valid", "connecting", "vue-flow__handle-valid", "vue-flow__handle-connecting");
}
function jo(e, t, n, o) {
  return (t[n] || []).reduce((i, r) => {
    var l, a;
    return `${e.id}-${r.id}-${n}` !== o && i.push({
      id: r.id || null,
      type: n,
      nodeId: e.id,
      x: (((l = e.computedPosition) == null ? void 0 : l.x) ?? 0) + r.x + r.width / 2,
      y: (((a = e.computedPosition) == null ? void 0 : a.y) ?? 0) + r.y + r.height / 2,
      width: r.width,
      height: r.height
    }), i;
  }, []);
}
function oc(e, t, n, o, i, r) {
  const { x: l, y: a } = ot(e), u = t.elementsFromPoint(l, a).find((N) => N.classList.contains("vue-flow__handle"));
  if (u) {
    const N = u.getAttribute("data-nodeid");
    if (N) {
      const f = ho(void 0, u), g = u.getAttribute("data-handleid"), _ = r({ nodeId: N, id: g, type: f });
      if (_)
        return {
          handle: {
            id: g,
            type: f,
            nodeId: N,
            x: n.x,
            y: n.y
          },
          validHandleResult: _
        };
    }
  }
  let c = [], d = 1 / 0;
  if (i.forEach((N) => {
    const f = Math.sqrt((N.x - n.x) ** 2 + (N.y - n.y) ** 2);
    if (f <= o) {
      const g = r(N);
      f <= d && (f < d ? c = [{ handle: N, validHandleResult: g }] : f === d && c.push({
        handle: N,
        validHandleResult: g
      }), d = f);
    }
  }), !c.length)
    return { handle: null, validHandleResult: ur() };
  if (c.length === 1)
    return c[0];
  const h = c.some(({ validHandleResult: N }) => N.isValid), p = c.some(({ handle: N }) => N.type === "target");
  return c.find(
    ({ handle: N, validHandleResult: f }) => p ? N.type === "target" : h ? f.isValid : !0
  ) || c[0];
}
function Jo(e, t, n, o, i, r, l, a, s, u) {
  const c = r === "target", d = a.querySelector(`.vue-flow__handle[data-id="${t == null ? void 0 : t.nodeId}-${t == null ? void 0 : t.id}-${t == null ? void 0 : t.type}"]`), { x: h, y: p } = ot(e), N = a.elementFromPoint(h, p), f = N != null && N.classList.contains("vue-flow__handle") ? N : d, g = ur();
  if (f) {
    g.handleDomNode = f;
    const _ = ho(void 0, f), v = f.getAttribute("data-nodeid"), b = f.getAttribute("data-handleid"), y = f.classList.contains("connectable"), M = f.classList.contains("connectableend"), x = {
      source: c ? v : o,
      sourceHandle: c ? b : i,
      target: c ? o : v,
      targetHandle: c ? i : b
    };
    g.connection = x;
    const V = y && M && (n === at.Strict ? c && _ === "source" || !c && _ === "target" : v !== o || b !== i);
    g.endHandle = {
      nodeId: v,
      handleId: b,
      type: _
    }, V && (g.isValid = l(x, {
      edges: s,
      sourceNode: u(x.source),
      targetNode: u(x.target)
    }));
  }
  return g;
}
function ic({ nodes: e, nodeId: t, handleId: n, handleType: o }) {
  return e.reduce((i, r) => {
    const { handleBounds: l } = r;
    let a = [], s = [];
    return l && (a = jo(r, l, "source", `${t}-${n}-${o}`), s = jo(r, l, "target", `${t}-${n}-${o}`)), i.push(...a, ...s), i;
  }, []);
}
function ho(e, t) {
  return e || (t != null && t.classList.contains("target") ? "target" : t != null && t.classList.contains("source") ? "source" : null);
}
function rc(e, t) {
  let n = null;
  return t ? n = "valid" : e && !t && (n = "invalid"), n;
}
const lc = ["production", "prod"];
function zt(e, ...t) {
  lc.includes(process.env.NODE_ENV || "") || console.warn(`[Vue Flow]: ${e}`, ...t);
}
function Qo(e, t, n) {
  const o = t.querySelectorAll(`.vue-flow__handle${e}`);
  if (!o || !o.length)
    return;
  const i = Array.from(o), r = t.getBoundingClientRect();
  return i.map((l) => {
    const a = l.getBoundingClientRect();
    return {
      id: l.getAttribute("data-handleid"),
      position: l.getAttribute("data-handlepos"),
      x: (a.left - r.left) / n,
      y: (a.top - r.top) / n,
      ...pn(l)
    };
  });
}
function jn(e, t, n, o, i, r = !1, l) {
  i.value = !1, e.selected ? (r || e.selected && t) && (o([e]), et(() => {
    l.blur();
  })) : n([e]);
}
function he(e) {
  return typeof A(e) < "u";
}
function ac(e, t, n) {
  if (!e.source || !e.target)
    return n(new Ee(_e.EDGE_INVALID, e.id)), !1;
  let o;
  return Be(e) ? o = e : o = {
    ...e,
    id: mn(e)
  }, o = uo(o), er(o, t) ? !1 : o;
}
function sc(e, t, n, o, i, r) {
  if (!t.source || !t.target)
    return r(new Ee(_e.EDGE_INVALID, e.id)), !1;
  const l = o(e.id);
  if (!l)
    return r(new Ee(_e.EDGE_NOT_FOUND, e.id)), !1;
  const { id: a, ...s } = e, u = {
    ...s,
    id: i ? mn(t) : a,
    source: t.source,
    target: t.target,
    sourceHandle: t.sourceHandle,
    targetHandle: t.targetHandle
  };
  return n.splice(n.indexOf(l), 1, u), u;
}
function ei(e, t, n, o) {
  const i = {}, r = e.reduce((a, s) => {
    if (!nt(s))
      return o(new Ee(_e.NODE_INVALID)), a;
    const u = Uu(s, {
      ...n(s.id),
      parentNode: s.parentNode
    });
    return s.parentNode && (i[s.parentNode] = !0), a.concat(u);
  }, []), l = [...r, ...t];
  for (const a of r) {
    const s = l.find((u) => u.id === a.parentNode);
    a.parentNode && !s && o(new Ee(_e.NODE_MISSING_PARENT, a.id, a.parentNode)), (a.parentNode || i[a.id]) && (i[a.id] && (a.isParent = !0), s && (s.isParent = !0));
  }
  return r;
}
function cr(e) {
  const {
    vueFlowRef: t,
    snapToGrid: n,
    snapGrid: o,
    noDragClassName: i,
    nodes: r,
    nodeExtent: l,
    nodeDragThreshold: a,
    viewport: s,
    autoPanOnNodeDrag: u,
    nodesDraggable: c,
    panBy: d,
    findNode: h,
    multiSelectionActive: p,
    nodesSelectionActive: N,
    selectNodesOnDrag: f,
    removeSelectedElements: g,
    addSelectedNodes: _,
    updateNodePositions: v,
    emits: b
  } = ye(), { onStart: y, onDrag: M, onStop: x, el: D, disabled: V, id: H, selectable: I, dragHandle: Z } = e, ee = ue(!1);
  let X = [], m, k = null, E = { x: void 0, y: void 0 }, O = { x: 0, y: 0 }, z = null, G = !1, P = 0, U = !1;
  const K = ld(), L = ({ x: $, y: te }) => {
    E = { x: $, y: te };
    let Q = !1;
    if (X = X.map((oe) => {
      const ne = { x: $ - oe.distance.x, y: te - oe.distance.y };
      n.value && (ne.x = o.value[0] * Math.round(ne.x / o.value[0]), ne.y = o.value[1] * Math.round(ne.y / o.value[1]));
      const { computedPosition: Y } = co(
        oe,
        ne,
        b.error,
        l.value,
        oe.parentNode ? h(oe.parentNode) : void 0
      );
      return Q = Q || oe.position.x !== Y.x || oe.position.y !== Y.y, oe.position = Y, oe;
    }), !!Q && (v(X, !0, !0), ee.value = !0, z)) {
      const [oe, ne] = Tn({
        id: H,
        dragItems: X,
        findNode: h
      });
      M({ event: z, node: oe, nodes: ne });
    }
  }, j = () => {
    if (!k)
      return;
    const [$, te] = ar(O, k);
    if ($ !== 0 || te !== 0) {
      const Q = {
        x: (E.x ?? 0) - $ / s.value.zoom,
        y: (E.y ?? 0) - te / s.value.zoom
      };
      d({ x: $, y: te }) && L(Q);
    }
    P = requestAnimationFrame(j);
  };
  return pe([() => se(V), D], ([$, te]) => {
    if (te) {
      const Q = ke(te);
      if ($)
        Q.on(".drag", null);
      else {
        const oe = (ne) => {
          G = !0;
          const Y = h(H);
          !f.value && !p.value && Y && (Y.selected || g()), Y && se(I) && f.value && jn(
            Y,
            p.value,
            _,
            g,
            N,
            !1,
            te
          );
          const ie = K(ne);
          if (E = ie, X = Ku(r.value, c.value, ie, h, H), X.length) {
            const [ge, xe] = Tn({
              id: H,
              dragItems: X,
              findNode: h
            });
            y({ event: ne.sourceEvent, node: ge, nodes: xe });
          }
        };
        m = ja().on("start", (ne) => {
          var Y;
          a.value === 0 && oe(ne), E = K(ne), k = ((Y = t.value) == null ? void 0 : Y.getBoundingClientRect()) || null, O = ot(ne.sourceEvent, k);
        }).on("drag", (ne) => {
          const Y = K(ne);
          if (!U && G && u.value && (U = !0, j()), !G) {
            const ie = Y.xSnapped - (E.x ?? 0), ge = Y.ySnapped - (E.y ?? 0);
            Math.sqrt(ie * ie + ge * ge) > a.value && oe(ne);
          }
          (E.x !== Y.xSnapped || E.y !== Y.ySnapped) && X.length && G && (z = ne.sourceEvent, O = ot(ne.sourceEvent, k), L(Y));
        }).on("end", (ne) => {
          if (G && (ee.value = !1, U = !1, G = !1, cancelAnimationFrame(P), X.length)) {
            v(X, !1, !1);
            const [Y, ie] = Tn({
              id: H,
              dragItems: X,
              findNode: h
            });
            x({ event: ne.sourceEvent, node: Y, nodes: ie });
          }
        }).filter((ne) => {
          const Y = ne.target, ie = se(Z);
          return !ne.button && (!i.value || !qo(Y, `.${i.value}`, te) && (!ie || qo(Y, ie, te)));
        }), Q.call(m);
      }
    }
  }), ee;
}
function uc() {
  return {
    edgesChange: R(),
    nodesChange: R(),
    nodeDoubleClick: R(),
    nodeClick: R(),
    nodeMouseEnter: R(),
    nodeMouseMove: R(),
    nodeMouseLeave: R(),
    nodeContextMenu: R(),
    nodeDragStart: R(),
    nodeDrag: R(),
    nodeDragStop: R(),
    nodesInitialized: R(),
    miniMapNodeClick: R(),
    miniMapNodeDoubleClick: R(),
    miniMapNodeMouseEnter: R(),
    miniMapNodeMouseMove: R(),
    miniMapNodeMouseLeave: R(),
    connect: R(),
    connectStart: R(),
    connectEnd: R(),
    clickConnectStart: R(),
    clickConnectEnd: R(),
    paneReady: R(),
    move: R(),
    moveStart: R(),
    moveEnd: R(),
    selectionDragStart: R(),
    selectionDrag: R(),
    selectionDragStop: R(),
    selectionContextMenu: R(),
    selectionStart: R(),
    selectionEnd: R(),
    viewportChangeStart: R(),
    viewportChange: R(),
    viewportChangeEnd: R(),
    paneScroll: R(),
    paneClick: R(),
    paneContextMenu: R(),
    paneMouseEnter: R(),
    paneMouseMove: R(),
    paneMouseLeave: R(),
    edgeContextMenu: R(),
    edgeMouseEnter: R(),
    edgeMouseMove: R(),
    edgeMouseLeave: R(),
    edgeDoubleClick: R(),
    edgeClick: R(),
    edgeUpdateStart: R(),
    edgeUpdate: R(),
    edgeUpdateEnd: R(),
    updateNodeInternals: R(),
    error: R((e) => zt(e.message))
  };
}
function cc(e, t) {
  Mr(() => {
    for (const [n, o] of Object.entries(t.value)) {
      const i = (r) => {
        e(n, r);
      };
      o.on(i), Bt(() => {
        o.off(i);
      });
    }
  });
}
function dr(e, t) {
  const n = {};
  for (const o in e)
    t.includes(o) || Object.defineProperty(n, o, { enumerable: !0, get: () => e[o] });
  return n;
}
const dc = ["data-id", "data-handleid", "data-nodeid", "data-handlepos"], fc = {
  name: "Handle",
  compatConfig: { MODE: 3 }
}, cn = /* @__PURE__ */ ve({
  ...fc,
  props: {
    id: null,
    type: null,
    position: { default: q.Top },
    isValidConnection: { type: Function },
    connectable: { type: [Boolean, String, Function], default: void 0 },
    connectableStart: { type: Boolean, default: !0 },
    connectableEnd: { type: Boolean, default: !0 }
  },
  setup(e) {
    const t = dr(e, ["position", "connectable", "connectableStart", "connectableEnd", "id"]), n = Jt(t, "type", "source"), o = Jt(t, "isValidConnection", void 0), {
      connectionStartHandle: i,
      connectionClickStartHandle: r,
      connectionEndHandle: l,
      vueFlowRef: a,
      nodesConnectable: s,
      noDragClassName: u,
      noPanClassName: c
    } = ye(), { id: d, node: h, nodeEl: p, connectedEdges: N } = ud(), f = ue(), g = le(() => e.id ?? `${d}__handle-${e.position}`), _ = le(() => typeof e.connectableStart < "u" ? e.connectableStart : !0), v = le(() => typeof e.connectableEnd < "u" ? e.connectableEnd : !0), { handlePointerDown: b, handleClick: y } = br({
      nodeId: d,
      handleId: g,
      isValidConnection: o,
      type: n
    }), M = le(() => Me(e.connectable) && e.connectable === "single" ? !N.value.some((I) => {
      const Z = I[`${n.value}Handle`];
      return I[n.value] !== d ? !1 : Z ? Z === g.value : !0;
    }) : Ie(e.connectable) ? N.value.filter((I) => {
      const Z = I[`${n.value}Handle`];
      return I[n.value] !== d ? !1 : Z ? Z === g.value : !0;
    }).length < e.connectable : bt(e.connectable) ? e.connectable(h, N.value) : he(e.connectable) ? e.connectable : s.value), x = le(
      () => {
        var I, Z, ee, X, m, k;
        return ((I = i.value) == null ? void 0 : I.nodeId) === d && ((Z = i.value) == null ? void 0 : Z.handleId) === g.value && ((ee = i.value) == null ? void 0 : ee.type) === n.value || ((X = l.value) == null ? void 0 : X.nodeId) === d && ((m = l.value) == null ? void 0 : m.handleId) === g.value && ((k = l.value) == null ? void 0 : k.type) === n.value;
      }
    ), D = le(
      () => {
        var I, Z, ee;
        return ((I = r.value) == null ? void 0 : I.nodeId) === d && ((Z = r.value) == null ? void 0 : Z.handleId) === g.value && ((ee = r.value) == null ? void 0 : ee.type) === n.value;
      }
    );
    Ze(() => h.initialized).toBe(!0, { flush: "post" }).then(() => {
      var O;
      const I = (O = h.handleBounds[n.value]) == null ? void 0 : O.find((z) => z.id === g.value);
      if (!a.value || I)
        return;
      const Z = a.value.querySelector(".vue-flow__transformationpane");
      if (!p.value || !f.value || !Z || !g.value)
        return;
      const ee = p.value.getBoundingClientRect(), X = f.value.getBoundingClientRect(), m = window.getComputedStyle(Z), { m22: k } = new window.DOMMatrixReadOnly(m.transform), E = {
        id: g.value,
        position: e.position,
        x: (X.left - ee.left) / k,
        y: (X.top - ee.top) / k,
        ...pn(f.value)
      };
      h.handleBounds[n.value] = [...h.handleBounds[n.value] ?? [], E];
    }), hi(() => {
      const I = h.handleBounds[n.value];
      I && (h.handleBounds[n.value] = I.filter((Z) => Z.id !== g.value));
    });
    function V(I) {
      const Z = fo(I);
      M.value && _.value && (Z && I.button === 0 || !Z) && b(I);
    }
    function H(I) {
      !d || !r.value && !_.value || M.value && y(I);
    }
    return (I, Z) => (ae(), de("div", {
      ref_key: "handle",
      ref: f,
      "data-id": `${A(d)}-${A(g)}-${A(n)}`,
      "data-handleid": A(g),
      "data-nodeid": A(d),
      "data-handlepos": e.position,
      class: it(["vue-flow__handle", [
        `vue-flow__handle-${e.position}`,
        `vue-flow__handle-${A(g)}`,
        A(u),
        A(c),
        A(n),
        {
          connectable: A(M),
          connecting: A(D),
          connectablestart: A(_),
          connectableend: A(v),
          connectionindicator: A(M) && (A(_) && !A(x) || A(v) && A(x))
        }
      ]]),
      onMousedown: V,
      onTouchstartPassive: V,
      onClick: H
    }, [
      Ne(I.$slots, "default", { id: e.id })
    ], 42, dc));
  }
}), xn = function({
  sourcePosition: e = q.Bottom,
  targetPosition: t = q.Top,
  label: n,
  connectable: o = !0,
  isValidTargetPos: i,
  isValidSourcePos: r
}) {
  return [
    fe(cn, { type: "target", position: t, connectable: o, isValidConnection: i }),
    typeof n != "string" && n ? fe(n) : fe("div", { innerHTML: n }),
    fe(cn, { type: "source", position: e, connectable: o, isValidConnection: r })
  ];
};
xn.props = ["sourcePosition", "targetPosition", "label", "isValidTargetPos", "isValidSourcePos", "connectable"];
xn.inheritAttrs = !1;
xn.compatConfig = { MODE: 3 };
const hc = xn, wn = function({
  sourcePosition: e = q.Bottom,
  label: t,
  connectable: n = !0,
  isValidSourcePos: o
}) {
  return [
    typeof t != "string" && t ? fe(t) : fe("div", { innerHTML: t }),
    fe(cn, { type: "source", position: e, connectable: n, isValidConnection: o })
  ];
};
wn.props = ["sourcePosition", "label", "isValidSourcePos", "connectable"];
wn.inheritAttrs = !1;
wn.compatConfig = { MODE: 3 };
const gc = wn, _n = function({
  targetPosition: e = q.Top,
  label: t,
  connectable: n = !0,
  isValidTargetPos: o
}) {
  return [
    fe(cn, { type: "target", position: e, connectable: n, isValidConnection: o }),
    typeof t != "string" && t ? fe(t) : fe("div", { innerHTML: t })
  ];
};
_n.props = ["targetPosition", "label", "isValidTargetPos", "connectable"];
_n.inheritAttrs = !1;
_n.compatConfig = { MODE: 3 };
const vc = _n, ti = Symbol("vueFlow"), fr = Symbol("nodeId"), hr = Symbol("nodeRef"), gr = Symbol("edgeId"), vr = Symbol("edgeRef"), bn = Symbol("slots"), pc = ve({
  name: "Node",
  compatConfig: { MODE: 3 },
  props: ["name", "type", "id", "draggable", "selectable", "focusable", "connectable", "node", "resizeObserver"],
  setup(e) {
    mt(fr, e.id);
    const {
      id: t,
      edges: n,
      noPanClassName: o,
      selectNodesOnDrag: i,
      nodesSelectionActive: r,
      multiSelectionActive: l,
      emits: a,
      findNode: s,
      removeSelectedNodes: u,
      addSelectedNodes: c,
      updateNodeDimensions: d,
      onUpdateNodeInternals: h,
      getIntersectingNodes: p,
      getNodeTypes: N,
      nodeExtent: f,
      elevateNodesOnSelect: g,
      disableKeyboardA11y: _,
      ariaLiveMessage: v,
      snapToGrid: b,
      snapGrid: y
    } = ye(), M = Er(), x = Mt(e, "node"), D = le(() => s(x.value.parentNode)), V = le(() => yn([x.value], n.value)), H = ue(null);
    mt(hr, H);
    const { emit: I, on: Z } = dd(x.value, a), ee = cr({
      id: e.id,
      el: H,
      disabled: () => !e.draggable,
      selectable: () => e.selectable,
      dragHandle: () => x.value.dragHandle,
      onStart($) {
        I.dragStart({ ...$, intersections: p(x.value) });
      },
      onDrag($) {
        I.drag({ ...$, intersections: p(x.value) });
      },
      onStop($) {
        I.dragStop({ ...$, intersections: p(x.value) });
      }
    }), X = le(() => x.value.class instanceof Function ? x.value.class(x.value) : x.value.class), m = le(() => {
      const $ = (x.value.style instanceof Function ? x.value.style(x.value) : x.value.style) || {}, te = x.value.width instanceof Function ? x.value.width(x.value) : x.value.width, Q = x.value.height instanceof Function ? x.value.height(x.value) : x.value.height;
      return te && ($.width = typeof te == "string" ? te : `${te}px`), Q && ($.height = typeof Q == "string" ? Q : `${Q}px`), $;
    }), k = () => Number(x.value.zIndex ?? m.value.zIndex ?? 0);
    return h(($) => {
      $.includes(e.id) && O();
    }), We(() => {
      e.resizeObserver.observe(H.value);
    }), gi(() => {
      e.resizeObserver.unobserve(H.value);
    }), pe(
      [() => x.value.type, () => x.value.sourcePosition, () => x.value.targetPosition],
      () => {
        d([{ id: e.id, nodeElement: H.value, forceUpdate: !0 }]);
      },
      { flush: "pre" }
    ), pe(
      [
        () => x.value.position.x,
        () => x.value.position.y,
        () => {
          var $;
          return ($ = D.value) == null ? void 0 : $.computedPosition.x;
        },
        () => {
          var $;
          return ($ = D.value) == null ? void 0 : $.computedPosition.y;
        },
        () => {
          var $;
          return ($ = D.value) == null ? void 0 : $.computedPosition.z;
        },
        () => k(),
        () => x.value.selected,
        () => x.value.dimensions.height,
        () => x.value.dimensions.width,
        () => {
          var $;
          return ($ = D.value) == null ? void 0 : $.dimensions.height;
        },
        () => {
          var $;
          return ($ = D.value) == null ? void 0 : $.dimensions.width;
        }
      ],
      ([$, te, Q, oe, ne, Y]) => {
        const ie = {
          x: $,
          y: te,
          z: Y + (g.value && x.value.selected ? 1e3 : 0)
        };
        Ie(Q) && Ie(oe) ? x.value.computedPosition = qu({ x: Q, y: oe, z: ne }, ie) : x.value.computedPosition = ie;
      },
      { flush: "post", immediate: !0 }
    ), pe([() => x.value.extent, f], ([$, te], [Q, oe]) => {
      ($ !== Q || te !== oe) && E();
    }), x.value.extent === "parent" || typeof x.value.extent == "object" && "range" in x.value.extent && x.value.extent.range === "parent" ? Ze(() => x.value.initialized).toBe(!0).then(E) : E(), () => fe(
      "div",
      {
        ref: H,
        "data-id": x.value.id,
        class: [
          "vue-flow__node",
          `vue-flow__node-${e.type === !1 ? "default" : e.name}`,
          {
            [o.value]: e.draggable,
            dragging: ee == null ? void 0 : ee.value,
            selected: x.value.selected,
            selectable: e.selectable,
            parent: x.value.isParent
          },
          X.value
        ],
        style: {
          zIndex: x.value.computedPosition.z ?? k(),
          transform: `translate(${x.value.computedPosition.x}px,${x.value.computedPosition.y}px)`,
          pointerEvents: e.selectable || e.draggable ? "all" : "none",
          visibility: x.value.initialized ? "visible" : "hidden",
          ...m.value
        },
        tabIndex: e.focusable ? 0 : void 0,
        role: e.focusable ? "button" : void 0,
        "aria-describedby": _.value ? void 0 : `${qi}-${t}`,
        "aria-label": x.value.ariaLabel,
        onMouseenter: z,
        onMousemove: G,
        onMouseleave: P,
        onContextmenu: U,
        onClick: L,
        onDblclick: K,
        onKeydown: j
      },
      [
        fe(e.type === !1 ? N.value.default : e.type, {
          id: x.value.id,
          type: x.value.type,
          data: x.value.data,
          events: { ...x.value.events, ...Z },
          selected: !!x.value.selected,
          resizing: !!x.value.resizing,
          dragging: ee.value,
          connectable: e.connectable,
          position: x.value.position,
          dimensions: x.value.dimensions,
          isValidTargetPos: x.value.isValidTargetPos,
          isValidSourcePos: x.value.isValidSourcePos,
          parent: x.value.parentNode,
          zIndex: x.value.computedPosition.z,
          targetPosition: x.value.targetPosition,
          sourcePosition: x.value.sourcePosition,
          label: x.value.label,
          dragHandle: x.value.dragHandle,
          onUpdateNodeInternals: O
        })
      ]
    );
    function E() {
      const $ = x.value.computedPosition;
      b.value && ($.x = y.value[0] * Math.round($.x / y.value[0]), $.y = y.value[1] * Math.round($.y / y.value[1]));
      const { computedPosition: te, position: Q } = co(
        x.value,
        $,
        a.error,
        f.value,
        D.value
      );
      (x.value.computedPosition.x !== te.x || x.value.computedPosition.y !== te.y) && (x.value.computedPosition = { ...x.value.computedPosition, ...te }), (x.value.position.x !== Q.x || x.value.position.y !== Q.y) && (x.value.position = Q);
    }
    function O() {
      H.value && d([{ id: e.id, nodeElement: H.value, forceUpdate: !0 }]);
    }
    function z($) {
      ee != null && ee.value || I.mouseEnter({ event: $, node: x.value, connectedEdges: V.value });
    }
    function G($) {
      ee != null && ee.value || I.mouseMove({ event: $, node: x.value, connectedEdges: V.value });
    }
    function P($) {
      ee != null && ee.value || I.mouseLeave({ event: $, node: x.value, connectedEdges: V.value });
    }
    function U($) {
      return I.contextMenu({ event: $, node: x.value, connectedEdges: V.value });
    }
    function K($) {
      return I.doubleClick({ event: $, node: x.value, connectedEdges: V.value });
    }
    function L($) {
      e.selectable && (!i.value || !e.draggable) && jn(
        x.value,
        l.value,
        c,
        u,
        r,
        !1,
        H.value
      ), I.click({ event: $, node: x.value, connectedEdges: V.value });
    }
    function j($) {
      if (!Qn($))
        if (ji.includes($.key) && e.selectable) {
          const te = $.key === "Escape";
          jn(
            x.value,
            l.value,
            c,
            u,
            r,
            te,
            H.value
          );
        } else
          !_.value && e.draggable && x.value.selected && pt[$.key] && (v.value = `Moved selected node ${$.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~x.value.position.x}, y: ${~~x.value.position.y}`, M(
            {
              x: pt[$.key].x,
              y: pt[$.key].y
            },
            $.shiftKey
          ));
    }
  }
}), mc = pc, yc = ["transform"], xc = ["width", "height", "x", "y", "rx", "ry"], wc = ["y"], _c = {
  name: "EdgeText",
  compatConfig: { MODE: 3 }
}, bc = /* @__PURE__ */ ve({
  ..._c,
  props: {
    "aria-activedescendant": null,
    "aria-atomic": { type: [Boolean, String] },
    "aria-autocomplete": null,
    "aria-busy": { type: [Boolean, String] },
    "aria-checked": { type: [Boolean, String] },
    "aria-colcount": null,
    "aria-colindex": null,
    "aria-colspan": null,
    "aria-controls": null,
    "aria-current": { type: [Boolean, String] },
    "aria-describedby": null,
    "aria-details": null,
    "aria-disabled": { type: [Boolean, String] },
    "aria-dropeffect": null,
    "aria-errormessage": null,
    "aria-expanded": { type: [Boolean, String] },
    "aria-flowto": null,
    "aria-grabbed": { type: [Boolean, String] },
    "aria-haspopup": { type: [Boolean, String] },
    "aria-hidden": { type: [Boolean, String] },
    "aria-invalid": { type: [Boolean, String] },
    "aria-keyshortcuts": null,
    "aria-label": null,
    "aria-labelledby": null,
    "aria-level": null,
    "aria-live": null,
    "aria-modal": { type: [Boolean, String] },
    "aria-multiline": { type: [Boolean, String] },
    "aria-multiselectable": { type: [Boolean, String] },
    "aria-orientation": null,
    "aria-owns": null,
    "aria-placeholder": null,
    "aria-posinset": null,
    "aria-pressed": { type: [Boolean, String] },
    "aria-readonly": { type: [Boolean, String] },
    "aria-relevant": null,
    "aria-required": { type: [Boolean, String] },
    "aria-roledescription": null,
    "aria-rowcount": null,
    "aria-rowindex": null,
    "aria-rowspan": null,
    "aria-selected": { type: [Boolean, String] },
    "aria-setsize": null,
    "aria-sort": null,
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null,
    innerHTML: null,
    class: null,
    style: null,
    color: null,
    height: null,
    id: null,
    lang: null,
    max: null,
    media: null,
    method: null,
    min: null,
    name: null,
    target: null,
    type: null,
    width: null,
    role: null,
    tabindex: null,
    "accent-height": null,
    accumulate: null,
    additive: null,
    "alignment-baseline": null,
    allowReorder: null,
    alphabetic: null,
    amplitude: null,
    "arabic-form": null,
    ascent: null,
    attributeName: null,
    attributeType: null,
    autoReverse: null,
    azimuth: null,
    baseFrequency: null,
    "baseline-shift": null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: null,
    by: null,
    calcMode: null,
    "cap-height": null,
    clip: null,
    "clip-path": null,
    clipPathUnits: null,
    "clip-rule": null,
    "color-interpolation": null,
    "color-interpolation-filters": null,
    "color-profile": null,
    "color-rendering": null,
    contentScriptType: null,
    contentStyleType: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    decelerate: null,
    descent: null,
    diffuseConstant: null,
    direction: null,
    display: null,
    divisor: null,
    "dominant-baseline": null,
    dur: null,
    dx: null,
    dy: null,
    edgeMode: null,
    elevation: null,
    "enable-background": null,
    end: null,
    exponent: null,
    externalResourcesRequired: null,
    fill: null,
    "fill-opacity": null,
    "fill-rule": null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    "flood-color": null,
    "flood-opacity": null,
    focusable: null,
    "font-family": null,
    "font-size": null,
    "font-size-adjust": null,
    "font-stretch": null,
    "font-style": null,
    "font-variant": null,
    "font-weight": null,
    format: null,
    from: null,
    fx: null,
    fy: null,
    g1: null,
    g2: null,
    "glyph-name": null,
    "glyph-orientation-horizontal": null,
    "glyph-orientation-vertical": null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    hanging: null,
    "horiz-adv-x": null,
    "horiz-origin-x": null,
    href: null,
    ideographic: null,
    "image-rendering": null,
    in2: null,
    in: null,
    intercept: null,
    k1: null,
    k2: null,
    k3: null,
    k4: null,
    k: null,
    kernelMatrix: null,
    kernelUnitLength: null,
    kerning: null,
    keyPoints: null,
    keySplines: null,
    keyTimes: null,
    lengthAdjust: null,
    "letter-spacing": null,
    "lighting-color": null,
    limitingConeAngle: null,
    local: null,
    "marker-end": null,
    markerHeight: null,
    "marker-mid": null,
    "marker-start": null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    mode: null,
    numOctaves: null,
    offset: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    "overline-position": null,
    "overline-thickness": null,
    "paint-order": null,
    "panose-1": null,
    pathLength: null,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    "pointer-events": null,
    points: null,
    pointsAtX: null,
    pointsAtY: null,
    pointsAtZ: null,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    r: null,
    radius: null,
    refX: null,
    refY: null,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: null,
    requiredFeatures: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    "shape-rendering": null,
    slope: null,
    spacing: null,
    specularConstant: null,
    specularExponent: null,
    speed: null,
    spreadMethod: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    "stop-color": null,
    "stop-opacity": null,
    "strikethrough-position": null,
    "strikethrough-thickness": null,
    string: null,
    stroke: null,
    "stroke-dasharray": null,
    "stroke-dashoffset": null,
    "stroke-linecap": null,
    "stroke-linejoin": null,
    "stroke-miterlimit": null,
    "stroke-opacity": null,
    "stroke-width": null,
    surfaceScale: null,
    systemLanguage: null,
    tableValues: null,
    targetX: null,
    targetY: null,
    "text-anchor": null,
    "text-decoration": null,
    textLength: null,
    "text-rendering": null,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    "underline-position": null,
    "underline-thickness": null,
    unicode: null,
    "unicode-bidi": null,
    "unicode-range": null,
    "unitsPer-em": null,
    "v-alphabetic": null,
    values: null,
    "vector-effect": null,
    version: null,
    "vert-adv-y": null,
    "vert-origin-x": null,
    "vert-origin-y": null,
    "v-hanging": null,
    "v-ideographic": null,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    "v-mathematical": null,
    widths: null,
    "word-spacing": null,
    "writing-mode": null,
    x1: null,
    x2: null,
    x: null,
    xChannelSelector: null,
    "x-height": null,
    xlinkActuate: null,
    xlinkArcrole: null,
    xlinkHref: null,
    xlinkRole: null,
    xlinkShow: null,
    xlinkTitle: null,
    xlinkType: null,
    xmlns: null,
    y1: null,
    y2: null,
    y: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null,
    label: null,
    labelStyle: { default: {} },
    labelShowBg: { type: Boolean, default: !0 },
    labelBgStyle: { default: {} },
    labelBgPadding: { default: [2, 4] },
    labelBgBorderRadius: { default: 2 }
  },
  setup(e) {
    const t = ue({ x: 0, y: 0, width: 0, height: 0 }), n = ue(null), o = le(() => `translate(${e.x - t.value.width / 2} ${e.y - t.value.height / 2})`);
    We(i), pe([() => e.x, () => e.y, n, () => e.label], i);
    function i() {
      if (!n.value)
        return;
      const r = n.value.getBBox();
      (r.width !== t.value.width || r.height !== t.value.height) && (t.value = r);
    }
    return (r, l) => (ae(), de("g", {
      transform: A(o),
      class: "vue-flow__edge-textwrapper"
    }, [
      e.labelShowBg ? (ae(), de("rect", {
        key: 0,
        class: "vue-flow__edge-textbg",
        width: `${t.value.width + 2 * e.labelBgPadding[0]}px`,
        height: `${t.value.height + 2 * e.labelBgPadding[1]}px`,
        x: -e.labelBgPadding[0],
        y: -e.labelBgPadding[1],
        style: De(e.labelBgStyle),
        rx: e.labelBgBorderRadius,
        ry: e.labelBgBorderRadius
      }, null, 12, xc)) : Te("", !0),
      yt("text", kr(r.$attrs, {
        ref_key: "el",
        ref: n,
        class: "vue-flow__edge-text",
        y: t.value.height / 2,
        dy: "0.3em",
        style: e.labelStyle
      }), [
        Ne(r.$slots, "default", {}, () => [
          A(Me)(e.label) ? (ae(), de(ze, { key: 1 }, [
            Tr(zn(e.label), 1)
          ], 64)) : (ae(), rt($r(e.label), { key: 0 }))
        ])
      ], 16, wc)
    ], 8, yc));
  }
}), Ec = ["id", "d", "marker-end", "marker-start"], Sc = ["d", "stroke-width"], Nc = {
  name: "BaseEdge",
  inheritAttrs: !1,
  compatConfig: { MODE: 3 }
}, En = /* @__PURE__ */ ve({
  ...Nc,
  props: {
    labelStyle: null,
    labelShowBg: { type: Boolean, default: !0 },
    labelBgStyle: null,
    labelBgPadding: null,
    labelBgBorderRadius: null,
    id: null,
    labelX: null,
    labelY: null,
    path: null,
    label: null,
    markerStart: null,
    markerEnd: null,
    interactionWidth: { default: 20 },
    style: null,
    ref: null
  },
  setup(e, { expose: t }) {
    const n = dr(e, ["interactionWidth", "labelShowBg"]), o = ue(null), i = ue(null), r = ue(null), l = Pr();
    return t({
      pathEl: o,
      interactionEl: i,
      labelEl: r
    }), (a, s) => (ae(), de(ze, null, [
      yt("path", {
        id: e.id,
        ref_key: "pathEl",
        ref: o,
        d: e.path,
        style: De(A(n).style),
        class: it(["vue-flow__edge-path", A(l).class]),
        "marker-end": e.markerEnd,
        "marker-start": e.markerStart
      }, null, 14, Ec),
      e.interactionWidth ? (ae(), de("path", {
        key: 0,
        ref_key: "interactionEl",
        ref: i,
        fill: "none",
        d: e.path,
        "stroke-width": e.interactionWidth,
        "stroke-opacity": 0,
        class: "vue-flow__edge-interaction"
      }, null, 8, Sc)) : Te("", !0),
      e.label && A(Ie)(e.labelX) && A(Ie)(e.labelY) ? (ae(), rt(bc, {
        key: 1,
        ref_key: "labelEl",
        ref: r,
        x: e.labelX,
        y: e.labelY,
        label: e.label,
        "label-show-bg": e.labelShowBg,
        "label-bg-style": e.labelBgStyle,
        "label-bg-padding": e.labelBgPadding,
        "label-bg-border-radius": e.labelBgBorderRadius,
        "label-style": e.labelStyle
      }, null, 8, ["x", "y", "label", "label-show-bg", "label-bg-style", "label-bg-padding", "label-bg-border-radius", "label-style"])) : Te("", !0)
    ], 64));
  }
});
function pr({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o
}) {
  const i = Math.abs(n - e) / 2, r = n < e ? n + i : n - i, l = Math.abs(o - t) / 2, a = o < t ? o + l : o - l;
  return [r, a, i, l];
}
function mr({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o,
  sourceControlX: i,
  sourceControlY: r,
  targetControlX: l,
  targetControlY: a
}) {
  const s = e * 0.125 + i * 0.375 + l * 0.375 + n * 0.125, u = t * 0.125 + r * 0.375 + a * 0.375 + o * 0.125, c = Math.abs(s - e), d = Math.abs(u - t);
  return [s, u, c, d];
}
function Xt(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function ni({ pos: e, x1: t, y1: n, x2: o, y2: i, c: r }) {
  let l, a;
  switch (e) {
    case q.Left:
      l = t - Xt(t - o, r), a = n;
      break;
    case q.Right:
      l = t + Xt(o - t, r), a = n;
      break;
    case q.Top:
      l = t, a = n - Xt(n - i, r);
      break;
    case q.Bottom:
      l = t, a = n + Xt(i - n, r);
      break;
  }
  return [l, a];
}
function yr({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = q.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = q.Top,
  curvature: l = 0.25
}) {
  const [a, s] = ni({
    pos: n,
    x1: e,
    y1: t,
    x2: o,
    y2: i,
    c: l
  }), [u, c] = ni({
    pos: r,
    x1: o,
    y1: i,
    x2: e,
    y2: t,
    c: l
  }), [d, h, p, N] = mr({
    sourceX: e,
    sourceY: t,
    targetX: o,
    targetY: i,
    sourceControlX: a,
    sourceControlY: s,
    targetControlX: u,
    targetControlY: c
  });
  return [
    `M${e},${t} C${a},${s} ${u},${c} ${o},${i}`,
    d,
    h,
    p,
    N
  ];
}
function oi({ pos: e, x1: t, y1: n, x2: o, y2: i }) {
  let r, l;
  switch (e) {
    case q.Left:
    case q.Right:
      r = 0.5 * (t + o), l = n;
      break;
    case q.Top:
    case q.Bottom:
      r = t, l = 0.5 * (n + i);
      break;
  }
  return [r, l];
}
function xr({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = q.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = q.Top
}) {
  const [l, a] = oi({
    pos: n,
    x1: e,
    y1: t,
    x2: o,
    y2: i
  }), [s, u] = oi({
    pos: r,
    x1: o,
    y1: i,
    x2: e,
    y2: t
  }), [c, d, h, p] = mr({
    sourceX: e,
    sourceY: t,
    targetX: o,
    targetY: i,
    sourceControlX: l,
    sourceControlY: a,
    targetControlX: s,
    targetControlY: u
  });
  return [
    `M${e},${t} C${l},${a} ${s},${u} ${o},${i}`,
    c,
    d,
    h,
    p
  ];
}
const ii = {
  [q.Left]: { x: -1, y: 0 },
  [q.Right]: { x: 1, y: 0 },
  [q.Top]: { x: 0, y: -1 },
  [q.Bottom]: { x: 0, y: 1 }
};
function Cc({
  source: e,
  sourcePosition: t = q.Bottom,
  target: n
}) {
  return t === q.Left || t === q.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
}
function ri(e, t) {
  return Math.sqrt((t.x - e.x) ** 2 + (t.y - e.y) ** 2);
}
function Mc({
  source: e,
  sourcePosition: t = q.Bottom,
  target: n,
  targetPosition: o = q.Top,
  center: i,
  offset: r
}) {
  const l = ii[t], a = ii[o], s = { x: e.x + l.x * r, y: e.y + l.y * r }, u = { x: n.x + a.x * r, y: n.y + a.y * r }, c = Cc({
    source: s,
    sourcePosition: t,
    target: u
  }), d = c.x !== 0 ? "x" : "y", h = c[d];
  let p, N, f;
  const g = { x: 0, y: 0 }, _ = { x: 0, y: 0 }, [v, b, y, M] = pr({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (l[d] * a[d] === -1) {
    N = i.x || v, f = i.y || b;
    const D = [
      { x: N, y: s.y },
      { x: N, y: u.y }
    ], V = [
      { x: s.x, y: f },
      { x: u.x, y: f }
    ];
    l[d] === h ? p = d === "x" ? D : V : p = d === "x" ? V : D;
  } else {
    const D = [{ x: s.x, y: u.y }], V = [{ x: u.x, y: s.y }];
    if (d === "x" ? p = l.x === h ? V : D : p = l.y === h ? D : V, t === o) {
      const X = Math.abs(e[d] - n[d]);
      if (X <= r) {
        const m = Math.min(r - 1, r - X);
        l[d] === h ? g[d] = m : _[d] = m;
      }
    }
    if (t !== o) {
      const X = d === "x" ? "y" : "x", m = l[d] === a[X], k = s[X] > u[X], E = s[X] < u[X];
      (l[d] === 1 && (!m && k || m && E) || l[d] !== 1 && (!m && E || m && k)) && (p = d === "x" ? D : V);
    }
    const H = { x: s.x - g.x, y: s.y - g.y }, I = { x: u.x - _.x, y: u.y - _.y }, Z = Math.max(Math.abs(H.x - p[0].x), Math.abs(I.x - p[0].x)), ee = Math.max(Math.abs(H.y - p[0].y), Math.abs(I.y - p[0].y));
    Z >= ee ? (N = (H.x + I.x) / 2, f = p[0].y) : (N = p[0].x, f = (H.y + I.y) / 2);
  }
  return [[
    e,
    { x: s.x - g.x, y: s.y - g.y },
    ...p,
    { x: u.x - _.x, y: u.y - _.y },
    n
  ], N, f, y, M];
}
function kc(e, t, n, o) {
  const i = Math.min(ri(e, t) / 2, ri(t, n) / 2, o), { x: r, y: l } = t;
  if (e.x === r && r === n.x || e.y === l && l === n.y)
    return `L${r} ${l}`;
  if (e.y === l) {
    const u = e.x < n.x ? -1 : 1, c = e.y < n.y ? 1 : -1;
    return `L ${r + i * u},${l}Q ${r},${l} ${r},${l + i * c}`;
  }
  const a = e.x < n.x ? 1 : -1, s = e.y < n.y ? -1 : 1;
  return `L ${r},${l + i * s}Q ${r},${l} ${r + i * a},${l}`;
}
function Jn({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = q.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = q.Top,
  borderRadius: l = 5,
  centerX: a,
  centerY: s,
  offset: u = 20
}) {
  const [c, d, h, p, N] = Mc({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: o, y: i },
    targetPosition: r,
    center: { x: a, y: s },
    offset: u
  });
  return [c.reduce((g, _, v) => {
    let b;
    return v > 0 && v < c.length - 1 ? b = kc(c[v - 1], _, c[v + 1], l) : b = `${v === 0 ? "M" : "L"}${_.x} ${_.y}`, g += b, g;
  }, ""), d, h, p, N];
}
function $c({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o
}) {
  const [i, r, l, a] = pr({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: o
  });
  return [`M ${e},${t}L ${n},${o}`, i, r, l, a];
}
const Tc = ve({
  name: "BezierEdge",
  props: [
    "sourcePosition",
    "targetPosition",
    "label",
    "labelStyle",
    "labelShowBg",
    "labelBgStyle",
    "labelBgPadding",
    "labelBgBorderRadius",
    "sourceY",
    "sourceX",
    "targetX",
    "targetY",
    "curvature",
    "markerEnd",
    "markerStart",
    "interactionWidth"
  ],
  compatConfig: { MODE: 3 },
  setup(e, { attrs: t }) {
    return () => {
      const [n, o, i] = yr({
        ...e,
        sourcePosition: e.sourcePosition ?? q.Bottom,
        targetPosition: e.targetPosition ?? q.Top
      });
      return fe(En, {
        path: n,
        labelX: o,
        labelY: i,
        ...t,
        ...e
      });
    };
  }
}), Pc = Tc, Oc = ve({
  name: "SimpleBezierEdge",
  props: [
    "sourcePosition",
    "targetPosition",
    "label",
    "labelStyle",
    "labelShowBg",
    "labelBgStyle",
    "labelBgPadding",
    "labelBgBorderRadius",
    "sourceY",
    "sourceX",
    "targetX",
    "targetY",
    "markerEnd",
    "markerStart",
    "interactionWidth"
  ],
  compatConfig: { MODE: 3 },
  setup(e, { attrs: t }) {
    return () => {
      const [n, o, i] = xr({
        ...e,
        sourcePosition: e.sourcePosition ?? q.Bottom,
        targetPosition: e.targetPosition ?? q.Top
      });
      return fe(En, {
        path: n,
        labelX: o,
        labelY: i,
        ...t,
        ...e
      });
    };
  }
}), Ic = Oc, Ac = ve({
  name: "SmoothStepEdge",
  props: [
    "sourcePosition",
    "targetPosition",
    "label",
    "labelStyle",
    "labelShowBg",
    "labelBgStyle",
    "labelBgPadding",
    "labelBgBorderRadius",
    "sourceY",
    "sourceX",
    "targetX",
    "targetY",
    "borderRadius",
    "markerEnd",
    "markerStart",
    "interactionWidth",
    "offset"
  ],
  compatConfig: { MODE: 3 },
  setup(e, { attrs: t }) {
    return () => {
      const [n, o, i] = Jn({
        ...e,
        sourcePosition: e.sourcePosition ?? q.Bottom,
        targetPosition: e.targetPosition ?? q.Top
      });
      return fe(En, {
        path: n,
        labelX: o,
        labelY: i,
        ...t,
        ...e
      });
    };
  }
}), wr = Ac, Dc = ve({
  name: "StepEdge",
  props: [
    "sourcePosition",
    "targetPosition",
    "label",
    "labelStyle",
    "labelShowBg",
    "labelBgStyle",
    "labelBgPadding",
    "labelBgBorderRadius",
    "sourceY",
    "sourceX",
    "targetX",
    "targetY",
    "markerEnd",
    "markerStart",
    "interactionWidth"
  ],
  setup(e, { attrs: t }) {
    return () => fe(wr, { ...e, ...t, borderRadius: 0 });
  }
}), zc = Dc, Bc = ve({
  name: "StraightEdge",
  props: [
    "label",
    "labelStyle",
    "labelShowBg",
    "labelBgStyle",
    "labelBgPadding",
    "labelBgBorderRadius",
    "sourceY",
    "sourceX",
    "targetX",
    "targetY",
    "markerEnd",
    "markerStart",
    "interactionWidth"
  ],
  compatConfig: { MODE: 3 },
  setup(e, { attrs: t }) {
    return () => {
      const [n, o, i] = $c(e);
      return fe(En, {
        path: n,
        labelX: o,
        labelY: i,
        ...t,
        ...e
      });
    };
  }
}), Rc = Bc;
function Vc(e, t, n) {
  return n === q.Left ? e - t : n === q.Right ? e + t : e;
}
function Hc(e, t, n) {
  return n === q.Top ? e - t : n === q.Bottom ? e + t : e;
}
const go = function({
  radius: e = 10,
  centerX: t = 0,
  centerY: n = 0,
  position: o = q.Top,
  type: i
}) {
  return fe("circle", {
    class: `vue-flow__edgeupdater vue-flow__edgeupdater-${i}`,
    cx: Vc(t, e, o),
    cy: Hc(n, e, o),
    r: e,
    stroke: "transparent",
    fill: "transparent"
  });
};
go.props = ["radius", "centerX", "centerY", "position", "type"];
go.compatConfig = { MODE: 3 };
const li = go, Lc = ve({
  name: "Edge",
  compatConfig: { MODE: 3 },
  props: ["name", "type", "id", "updatable", "selectable", "focusable", "edge"],
  setup(e) {
    const {
      id: t,
      addSelectedEdges: n,
      connectionMode: o,
      edgeUpdaterRadius: i,
      emits: r,
      nodesSelectionActive: l,
      noPanClassName: a,
      getEdgeTypes: s,
      removeSelectedEdges: u,
      findEdge: c,
      findNode: d,
      isValidConnection: h,
      multiSelectionActive: p
    } = ye(), N = rd(e.edge, r), f = Mt(e, "edge"), g = ue(!1), _ = ue(!1), v = ue(""), b = ue(null), y = ue("source"), M = ue(null);
    mt(gr, e.id), mt(vr, M);
    const x = le(() => f.value.class instanceof Function ? f.value.class(f.value) : f.value.class), D = le(() => f.value.style instanceof Function ? f.value.style(f.value) : f.value.style), { handlePointerDown: V } = br({
      nodeId: v,
      handleId: b,
      type: y,
      isValidConnection: h,
      edgeUpdaterType: y,
      onEdgeUpdate: Z,
      onEdgeUpdateEnd: ee
    });
    return () => {
      const L = d(f.value.source), j = d(f.value.target);
      if (!L || !j || !f.value || L.hidden || j.hidden)
        return null;
      let $;
      o.value === at.Strict ? $ = L.handleBounds.source : $ = [...L.handleBounds.source || [], ...L.handleBounds.target || []];
      const te = Ko($, f.value.sourceHandle);
      let Q;
      o.value === at.Strict ? Q = j.handleBounds.target : Q = [...j.handleBounds.target || [], ...j.handleBounds.source || []];
      const oe = Ko(Q, f.value.targetHandle), ne = te ? te.position : q.Bottom, Y = oe ? oe.position : q.Top, { sourceX: ie, sourceY: ge, targetY: xe, targetX: we } = ec(
        L,
        te,
        ne,
        j,
        oe,
        Y
      );
      return f.value.sourceX = ie, f.value.sourceY = ge, f.value.targetX = we, f.value.targetY = xe, fe(
        "g",
        {
          ref: M,
          key: e.id,
          "data-id": e.id,
          class: [
            "vue-flow__edge",
            `vue-flow__edge-${e.type === !1 ? "default" : e.name}`,
            a.value,
            x.value,
            {
              updating: g.value,
              selected: f.value.selected,
              animated: f.value.animated,
              inactive: !e.selectable
            }
          ],
          onClick: m,
          onContextmenu: k,
          onDblclick: E,
          onMouseenter: O,
          onMousemove: z,
          onMouseleave: G,
          onKeyDown: e.focusable ? K : void 0,
          tabIndex: e.focusable ? 0 : void 0,
          "aria-label": f.value.ariaLabel === null ? void 0 : f.value.ariaLabel || `Edge from ${f.value.source} to ${f.value.target}`,
          "aria-describedby": e.focusable ? `${Ki}-${t}` : void 0,
          role: e.focusable ? "button" : "img"
        },
        [
          _.value ? null : fe(e.type === !1 ? s.value.default : e.type, {
            id: e.id,
            sourceNode: L,
            targetNode: j,
            source: f.value.source,
            target: f.value.target,
            type: f.value.type,
            updatable: e.updatable,
            selected: f.value.selected,
            animated: f.value.animated,
            label: f.value.label,
            labelStyle: f.value.labelStyle,
            labelShowBg: f.value.labelShowBg,
            labelBgStyle: f.value.labelBgStyle,
            labelBgPadding: f.value.labelBgPadding,
            labelBgBorderRadius: f.value.labelBgBorderRadius,
            data: f.value.data,
            events: { ...f.value.events, ...N.on },
            style: D.value,
            markerStart: `url(#${Qe(f.value.markerStart, t)})`,
            markerEnd: `url(#${Qe(f.value.markerEnd, t)})`,
            sourcePosition: ne,
            targetPosition: Y,
            sourceX: ie,
            sourceY: ge,
            targetX: we,
            targetY: xe,
            sourceHandleId: f.value.sourceHandle,
            targetHandleId: f.value.targetHandle,
            interactionWidth: f.value.interactionWidth
          }),
          [
            e.updatable === "source" || e.updatable === !0 ? [
              fe(
                "g",
                {
                  onMousedown: P,
                  onMouseenter: H,
                  onMouseout: I
                },
                fe(li, {
                  position: ne,
                  centerX: ie,
                  centerY: ge,
                  radius: i.value,
                  type: "source",
                  "data-type": "source"
                })
              )
            ] : null,
            e.updatable === "target" || e.updatable === !0 ? [
              fe(
                "g",
                {
                  onMousedown: U,
                  onMouseenter: H,
                  onMouseout: I
                },
                fe(li, {
                  position: Y,
                  centerX: we,
                  centerY: xe,
                  radius: i.value,
                  type: "target",
                  "data-type": "target"
                })
              )
            ] : null
          ]
        ]
      );
    };
    function H() {
      g.value = !0;
    }
    function I() {
      g.value = !1;
    }
    function Z(L, j) {
      N.emit.update({ event: L, edge: f.value, connection: j });
    }
    function ee(L) {
      N.emit.updateEnd({ event: L, edge: f.value }), _.value = !1;
    }
    function X(L, j) {
      L.button === 0 && (_.value = !0, v.value = j ? f.value.target : f.value.source, b.value = (j ? f.value.targetHandle : f.value.sourceHandle) ?? "", y.value = j ? "target" : "source", N.emit.updateStart({ event: L, edge: f.value }), V(L));
    }
    function m(L) {
      var $;
      const j = { event: L, edge: f.value };
      e.selectable && (l.value = !1, f.value.selected && p.value ? (u([f.value]), ($ = M.value) == null || $.blur()) : n([f.value])), N.emit.click(j);
    }
    function k(L) {
      N.emit.contextMenu({ event: L, edge: f.value });
    }
    function E(L) {
      N.emit.doubleClick({ event: L, edge: f.value });
    }
    function O(L) {
      N.emit.mouseEnter({ event: L, edge: f.value });
    }
    function z(L) {
      N.emit.mouseMove({ event: L, edge: f.value });
    }
    function G(L) {
      N.emit.mouseLeave({ event: L, edge: f.value });
    }
    function P(L) {
      X(L, !0);
    }
    function U(L) {
      X(L, !1);
    }
    function K(L) {
      var j;
      ji.includes(L.key) && e.selectable && (L.key === "Escape" ? ((j = M.value) == null || j.blur(), u([c(e.id)])) : n([c(e.id)]));
    }
  }
}), Fc = Lc, Gc = {
  height: "0",
  width: "0"
}, Yc = {
  name: "EdgeLabelRenderer",
  compatConfig: { MODE: 3 }
}, Xd = /* @__PURE__ */ ve({
  ...Yc,
  setup(e) {
    const { viewportRef: t } = ye(), n = Jt(() => t.value.getElementsByClassName("vue-flow__edge-labels")[0]);
    return (o, i) => (ae(), de("svg", null, [
      (ae(), de("foreignObject", Gc, [
        (ae(), rt(Or, {
          to: A(n),
          disabled: !A(n)
        }, [
          Ne(o.$slots, "default")
        ], 8, ["to", "disabled"]))
      ]))
    ]));
  }
}), Xc = {
  [q.Left]: q.Right,
  [q.Right]: q.Left,
  [q.Top]: q.Bottom,
  [q.Bottom]: q.Top
}, Uc = ve({
  name: "ConnectionLine",
  compatConfig: { MODE: 3 },
  setup() {
    var d;
    const {
      connectionMode: e,
      connectionStartHandle: t,
      connectionEndHandle: n,
      connectionPosition: o,
      connectionLineType: i,
      connectionLineStyle: r,
      connectionLineOptions: l,
      connectionStatus: a,
      viewport: s,
      findNode: u
    } = ye(), c = (d = qe(bn)) == null ? void 0 : d["connection-line"];
    return () => {
      var X, m, k, E;
      if (!t.value)
        return null;
      const h = u(t.value.nodeId);
      if (!h)
        return null;
      const p = t.value.handleId, N = t.value.type, f = ((X = n.value) == null ? void 0 : X.handleId) && u(n.value.nodeId) || null, g = (o.value.x - s.value.x) / s.value.zoom, _ = (o.value.y - s.value.y) / s.value.zoom, v = h.handleBounds;
      let b = v == null ? void 0 : v[N];
      if (e.value === at.Loose && (b = b || (v == null ? void 0 : v[N === "source" ? "target" : "source"])), !b)
        return null;
      const y = (p ? b.find((O) => O.id === p) : b[0]) ?? null, M = (y == null ? void 0 : y.position) || q.Top, { x, y: D } = Kn(
        M,
        { ...h.dimensions, ...h.computedPosition },
        y
      ), V = f && ((m = n.value) == null ? void 0 : m.handleId) && ((e.value === at.Strict ? (k = f.handleBounds[N === "source" ? "target" : "source"]) == null ? void 0 : k.find(
        (O) => {
          var z;
          return O.id === ((z = n.value) == null ? void 0 : z.handleId);
        }
      ) : [...f.handleBounds.source || [], ...f.handleBounds.target || []].find(
        (O) => {
          var z;
          return O.id === ((z = n.value) == null ? void 0 : z.handleId);
        }
      )) || ((E = f.handleBounds[N ?? "target"]) == null ? void 0 : E[0])) || null, H = M ? Xc[M] : null;
      if (!M || !H)
        return null;
      const I = i.value ?? l.value.type;
      let Z = "";
      const ee = {
        sourceX: x,
        sourceY: D,
        sourcePosition: M,
        targetX: g,
        targetY: _,
        targetPosition: H
      };
      return I === ct.Bezier ? [Z] = yr(ee) : I === ct.Step ? [Z] = Jn({
        ...ee,
        borderRadius: 0
      }) : I === ct.SmoothStep ? [Z] = Jn(ee) : I === ct.SimpleBezier ? [Z] = xr(ee) : Z = `M${x},${D} ${g},${_}`, fe(
        "svg",
        { class: "vue-flow__edges vue-flow__connectionline vue-flow__container" },
        fe(
          "g",
          { class: "vue-flow__connection" },
          c ? fe(c, {
            sourceX: x,
            sourceY: D,
            sourcePosition: M,
            targetX: g,
            targetY: _,
            targetPosition: H,
            sourceNode: h,
            sourceHandle: y,
            targetNode: f,
            targetHandle: V,
            markerEnd: `url(#${Qe(l.value.markerEnd)})`,
            markerStart: `url(#${Qe(l.value.markerStart)})`,
            connectionStatus: a.value
          }) : fe("path", {
            d: Z,
            class: [l.value.class, a, "vue-flow__connection-path"],
            style: r.value || l.value.style,
            "marker-end": `url(#${Qe(l.value.markerEnd)})`,
            "marker-start": `url(#${Qe(l.value.markerStart)})`
          })
        )
      );
    };
  }
}), Zc = Uc, Wc = ["tabIndex"], qc = {
  name: "NodesSelection",
  compatConfig: { MODE: 3 }
}, Kc = /* @__PURE__ */ ve({
  ...qc,
  setup(e) {
    const t = ye(), n = me(t, "emits"), o = me(t, "viewport"), i = me(t, "getSelectedNodes"), r = me(t, "noPanClassName"), l = me(t, "disableKeyboardA11y"), a = me(t, "userSelectionActive"), s = Er(), u = ue(null), c = cr({
      el: u,
      onStart(f) {
        n.value.selectionDragStart(f);
      },
      onDrag(f) {
        n.value.selectionDrag(f);
      },
      onStop(f) {
        n.value.selectionDragStop(f);
      }
    });
    We(() => {
      var f;
      l.value || (f = u.value) == null || f.focus({ preventScroll: !0 });
    });
    const d = le(() => ir(i.value)), h = le(() => ({
      width: `${d.value.width}px`,
      height: `${d.value.height}px`,
      top: `${d.value.y}px`,
      left: `${d.value.x}px`
    }));
    function p(f) {
      n.value.selectionContextMenu({ event: f, nodes: i.value });
    }
    function N(f) {
      l.value || pt[f.key] && s(
        {
          x: pt[f.key].x,
          y: pt[f.key].y
        },
        f.shiftKey
      );
    }
    return (f, g) => !A(a) && A(d).width && A(d).height ? (ae(), de("div", {
      key: 0,
      class: it(["vue-flow__nodesselection vue-flow__container", A(r)]),
      style: De({ transform: `translate(${A(o).x}px,${A(o).y}px) scale(${A(o).zoom})` })
    }, [
      yt("div", {
        ref_key: "el",
        ref: u,
        class: it([{ dragging: A(c) }, "vue-flow__nodesselection-rect"]),
        style: De(A(h)),
        tabIndex: A(l) ? void 0 : -1,
        onContextmenu: p,
        onKeydown: N
      }, null, 46, Wc)
    ], 6)) : Te("", !0);
  }
}), jc = {
  name: "UserSelection",
  compatConfig: { MODE: 3 }
}, Jc = /* @__PURE__ */ ve({
  ...jc,
  props: {
    userSelectionRect: null
  },
  setup(e) {
    return (t, n) => (ae(), de("div", {
      class: "vue-flow__selection vue-flow__container",
      style: De({
        width: `${e.userSelectionRect.width}px`,
        height: `${e.userSelectionRect.height}px`,
        transform: `translate(${e.userSelectionRect.x}px, ${e.userSelectionRect.y}px)`
      })
    }, null, 4));
  }
}), Qc = {
  input: gc,
  default: hc,
  output: vc
}, ed = {
  default: Pc,
  straight: Rc,
  step: zc,
  smoothstep: wr,
  simplebezier: Ic
};
function td() {
  return {
    vueFlowRef: null,
    viewportRef: null,
    // todo: change this to a Set
    nodes: [],
    // todo: change this to a Set
    edges: [],
    nodeTypes: {},
    edgeTypes: {},
    initialized: !1,
    dimensions: {
      width: 0,
      height: 0
    },
    viewport: { x: 0, y: 0, zoom: 1 },
    d3Zoom: null,
    d3Selection: null,
    d3ZoomHandler: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: [
      [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
      [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
    ],
    nodeExtent: [
      [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
      [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
    ],
    selectionMode: so.Full,
    paneDragging: !1,
    preventScrolling: !0,
    zoomOnScroll: !0,
    zoomOnPinch: !0,
    zoomOnDoubleClick: !0,
    panOnScroll: !1,
    panOnScrollSpeed: 0.5,
    panOnScrollMode: kt.Free,
    panOnDrag: !0,
    edgeUpdaterRadius: 10,
    onlyRenderVisibleElements: !1,
    defaultViewport: { x: 0, y: 0, zoom: 1 },
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    defaultMarkerColor: "#b1b1b7",
    connectionLineStyle: {},
    connectionLineType: null,
    connectionLineOptions: {
      type: ct.Bezier,
      style: {}
    },
    connectionMode: at.Loose,
    connectionStartHandle: null,
    connectionEndHandle: null,
    connectionClickStartHandle: null,
    connectionPosition: { x: NaN, y: NaN },
    connectionRadius: 20,
    connectOnClick: !0,
    connectionStatus: null,
    isValidConnection: null,
    snapGrid: [15, 15],
    snapToGrid: !1,
    edgesUpdatable: !1,
    edgesFocusable: !0,
    nodesFocusable: !0,
    nodesConnectable: !0,
    nodesDraggable: !0,
    nodeDragThreshold: 0,
    elementsSelectable: !0,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    selectionKeyCode: "Shift",
    multiSelectionKeyCode: un() ? "Meta" : "Control",
    zoomActivationKeyCode: un() ? "Meta" : "Control",
    deleteKeyCode: "Backspace",
    panActivationKeyCode: "Space",
    hooks: uc(),
    applyDefault: !0,
    autoConnect: !1,
    fitViewOnInit: !1,
    noDragClassName: "nodrag",
    noWheelClassName: "nowheel",
    noPanClassName: "nopan",
    defaultEdgeOptions: void 0,
    elevateEdgesOnSelect: !1,
    elevateNodesOnSelect: !0,
    autoPanOnNodeDrag: !0,
    autoPanOnConnect: !0,
    disableKeyboardA11y: !1,
    ariaLiveMessage: "",
    __experimentalFeatures: {
      nestedFlow: !1
    }
  };
}
function _r(e) {
  const t = td();
  return e && Object.keys(e).forEach((n) => {
    const o = e[n];
    he(o) && (t[n] = o);
  }), t;
}
function nd(e, t, n, o, i, r, l) {
  const a = Sr(o, i), s = (w) => {
    const C = w ?? r.value ?? [];
    o.hooks.updateNodeInternals.trigger(C);
  }, u = (w) => Wu(w, o.nodes, o.edges), c = (w) => Zu(w, o.nodes, o.edges), d = (w) => yn(w, o.edges), h = (w) => {
    if (w)
      return o.nodes && !r.value.length ? o.nodes.find((C) => C.id === w) : o.nodes[r.value.indexOf(w)];
  }, p = (w) => {
    if (w)
      return o.edges && !l.value.length ? o.edges.find((C) => C.id === w) : o.edges[l.value.indexOf(w)];
  }, N = (w, C, F) => {
    const S = [];
    w.forEach((T) => {
      var W, re;
      const B = {
        id: T.id,
        type: "position",
        dragging: F,
        from: T.from
      };
      if (C && (B.position = T.position, T.parentNode)) {
        const J = h(T.parentNode);
        B.position = {
          x: B.position.x - (((W = J == null ? void 0 : J.computedPosition) == null ? void 0 : W.x) ?? 0),
          y: B.position.y - (((re = J == null ? void 0 : J.computedPosition) == null ? void 0 : re.y) ?? 0)
        };
      }
      S.push(B);
    }), S != null && S.length && o.hooks.nodesChange.trigger(S);
  }, f = (w) => {
    var T;
    if (!o.vueFlowRef)
      return;
    const C = o.vueFlowRef.querySelector(".vue-flow__transformationpane");
    if (!C)
      return;
    let F;
    if ((T = o.__experimentalFeatures) != null && T.nestedFlow) {
      let B = [C], W = C, re;
      for (; !re && W; )
        W = W.parentElement, re = W == null ? void 0 : W.classList.contains("vue-flow__transformationpane"), re && (B = [W, ...B]);
      B.forEach((J) => {
        const ce = window.getComputedStyle(J), { m22: be } = new window.DOMMatrixReadOnly(ce.transform);
        F ? F *= be : F = be;
      });
    } else {
      const B = window.getComputedStyle(C), { m22: W } = new window.DOMMatrixReadOnly(B.transform);
      F = W;
    }
    const S = w.reduce((B, W) => {
      const re = h(W.id);
      if (re) {
        const J = pn(W.nodeElement);
        !!(J.width && J.height && (re.dimensions.width !== J.width || re.dimensions.height !== J.height || W.forceUpdate)) && (re.handleBounds.source = Qo(".source", W.nodeElement, F), re.handleBounds.target = Qo(".target", W.nodeElement, F), re.dimensions = J, re.initialized = !0, B.push({
          id: re.id,
          type: "dimensions",
          dimensions: J
        }));
      }
      return B;
    }, []);
    S.length && o.hooks.nodesChange.trigger(S);
  }, g = (w, C) => {
    const F = w.map((B) => B.id);
    let S, T = [];
    if (o.multiSelectionActive)
      S = F.map((B) => He(B, C));
    else {
      const B = $n([...o.nodes, ...o.edges], F);
      S = B.changedNodes, T = B.changedEdges;
    }
    S.length && o.hooks.nodesChange.trigger(S), T.length && o.hooks.edgesChange.trigger(T);
  }, _ = (w, C) => {
    const F = w.map((B) => B.id);
    let S = [], T;
    if (o.multiSelectionActive)
      T = F.map((B) => He(B, C));
    else {
      const B = $n([...o.nodes, ...o.edges], F);
      S = B.changedNodes, T = B.changedEdges;
    }
    S.length && o.hooks.nodesChange.trigger(S), T.length && o.hooks.edgesChange.trigger(T);
  }, v = (w, C) => {
    const F = w.filter(nt).map((W) => W.id), S = w.filter(Be).map((W) => W.id);
    let { changedNodes: T, changedEdges: B } = $n([...o.nodes, ...o.edges], [...F, ...S]);
    o.multiSelectionActive && (T = F.map((W) => He(W, C)), B = S.map((W) => He(W, C))), T.length && o.hooks.nodesChange.trigger(T), B.length && o.hooks.edgesChange.trigger(B);
  }, b = (w) => {
    g(w, !0);
  }, y = (w) => {
    _(w, !0);
  }, M = (w) => {
    v(w, !0);
  }, x = (w) => {
    if (!w.length)
      return g(w, !1);
    const F = w.map((S) => S.id).map((S) => He(S, !1));
    F.length && o.hooks.nodesChange.trigger(F);
  }, D = (w) => {
    if (!w.length)
      return _(w, !1);
    const F = w.map((S) => S.id).map((S) => He(S, !1));
    F.length && o.hooks.edgesChange.trigger(F);
  }, V = (w) => {
    if (!w || !w.length)
      return v([], !1);
    const C = w.reduce(
      (F, S) => {
        const T = He(S.id, !1);
        return nt(S) ? F.nodes.push(T) : F.edges.push(T), F;
      },
      { nodes: [], edges: [] }
    );
    C.nodes.length && o.hooks.nodesChange.trigger(C.nodes), C.edges.length && o.hooks.edgesChange.trigger(C.edges);
  }, H = (w) => {
    var C;
    (C = o.d3Zoom) == null || C.scaleExtent([w, o.maxZoom]), o.minZoom = w;
  }, I = (w) => {
    var C;
    (C = o.d3Zoom) == null || C.scaleExtent([o.minZoom, w]), o.maxZoom = w;
  }, Z = (w) => {
    var C;
    (C = o.d3Zoom) == null || C.translateExtent(w), o.translateExtent = w;
  }, ee = (w) => {
    o.nodeExtent = w, s(r.value);
  }, X = (w) => {
    o.nodesDraggable = w, o.nodesConnectable = w, o.elementsSelectable = w;
  }, m = (w) => {
    const C = w instanceof Function ? w(o.nodes) : w;
    !o.initialized && !C.length || (o.nodes = ei(C, o.nodes, h, o.hooks.error.trigger));
  }, k = (w) => {
    const C = w instanceof Function ? w(o.edges) : w;
    if (!o.initialized && !C.length)
      return;
    const F = o.isValidConnection ? C.filter(
      (S) => o.isValidConnection(S, {
        edges: o.edges,
        sourceNode: h(S.source),
        targetNode: h(S.target)
      })
    ) : C;
    o.edges = F.reduce((S, T) => {
      const B = h(T.source), W = h(T.target), re = !B || typeof B > "u", J = !W || typeof W > "u";
      if (re && J ? o.hooks.error.trigger(new Ee(_e.EDGE_SOURCE_TARGET_MISSING, T.id, T.source, T.target)) : (re && o.hooks.error.trigger(new Ee(_e.EDGE_SOURCE_MISSING, T.id, T.source)), J && o.hooks.error.trigger(new Ee(_e.EDGE_TARGET_MISSING, T.id, T.target))), re || J)
        return S;
      const ce = p(T.id);
      return S.push({
        ...uo(T, Object.assign({}, ce, o.defaultEdgeOptions)),
        sourceNode: B,
        targetNode: W
      }), S;
    }, []);
  }, E = (w) => {
    const C = w instanceof Function ? w([...o.nodes, ...o.edges]) : w;
    !o.initialized && !C.length || (m(C.filter(nt)), k(C.filter(Be)));
  }, O = (w) => {
    let C = w instanceof Function ? w(o.nodes) : w;
    C = Array.isArray(C) ? C : [C];
    const S = ei(C, o.nodes, h, o.hooks.error.trigger).map(Uo);
    S.length && o.hooks.nodesChange.trigger(S);
  }, z = (w) => {
    let C = w instanceof Function ? w(o.edges) : w;
    C = Array.isArray(C) ? C : [C];
    const S = (o.isValidConnection ? C.filter(
      (T) => o.isValidConnection(T, {
        edges: o.edges,
        sourceNode: h(T.source),
        targetNode: h(T.target)
      })
    ) : C).reduce((T, B) => {
      const W = ac(
        {
          ...B,
          ...o.defaultEdgeOptions
        },
        o.edges,
        o.hooks.error.trigger
      );
      if (W) {
        const re = h(W.source), J = h(W.target), ce = !re || typeof re > "u", be = !J || typeof J > "u";
        if (ce && be)
          return o.hooks.error.trigger(new Ee(_e.EDGE_SOURCE_TARGET_MISSING, W.id, W.source, W.target)), T;
        if (ce)
          return o.hooks.error.trigger(new Ee(_e.EDGE_SOURCE_MISSING, W.id, W.source)), T;
        if (be)
          return o.hooks.error.trigger(new Ee(_e.EDGE_TARGET_MISSING, W.id, W.target)), T;
        T.push(
          Uo({
            ...W,
            sourceNode: re,
            targetNode: J
          })
        );
      }
      return T;
    }, []);
    S.length && o.hooks.edgesChange.trigger(S);
  }, G = (w, C = !0, F = !1) => {
    let S = w instanceof Function ? w(o.nodes) : w;
    S = Array.isArray(S) ? S : [S];
    const T = [], B = [];
    function W(J) {
      const ce = d(J).filter((be) => he(be.deletable) ? be.deletable : !0);
      B.push(
        ...ce.map((be) => Wo(be.id, be.source, be.target))
      );
    }
    function re(J) {
      const ce = o.nodes.filter((be) => be.parentNode === J);
      if (ce.length) {
        const be = ce.map((Ke) => Ke.id);
        T.push(...be.map((Ke) => Zo(Ke))), C && W(ce), ce.forEach((Ke) => {
          re(Ke.id);
        });
      }
    }
    S.forEach((J) => {
      const ce = typeof J == "string" ? h(J) : J;
      ce && (he(ce.deletable) && !ce.deletable || (T.push(Zo(ce.id)), C && W([ce]), F && re(ce.id)));
    }), B.length && o.hooks.edgesChange.trigger(B), T.length && o.hooks.nodesChange.trigger(T);
  }, P = (w) => {
    let C = w instanceof Function ? w(o.edges) : w;
    C = Array.isArray(C) ? C : [C];
    const F = [];
    C.forEach((S) => {
      const T = typeof S == "string" ? p(S) : S;
      T && (he(T.deletable) && !T.deletable || F.push(Wo(typeof S == "string" ? S : S.id, T.source, T.target)));
    }), o.hooks.edgesChange.trigger(F);
  }, U = (w, C, F = !0) => sc(w, C, o.edges, p, F, o.hooks.error.trigger), K = (w) => sn(w, o.nodes), L = (w) => sn(w, o.edges), j = (w, C, F, S = !1) => {
    S ? o.connectionClickStartHandle = w : o.connectionStartHandle = w, o.connectionEndHandle = null, o.connectionStatus = null, C && (o.connectionPosition = C);
  }, $ = (w, C = null, F = null) => {
    o.connectionStartHandle && (o.connectionPosition = w, o.connectionEndHandle = C, o.connectionStatus = F);
  }, te = (w, C) => {
    o.connectionPosition = { x: NaN, y: NaN }, o.connectionEndHandle = null, o.connectionStatus = null, C ? o.connectionClickStartHandle = null : o.connectionStartHandle = null;
  }, Q = (w) => {
    const C = Xu(w), F = C ? null : h(w.id);
    return !C && !F ? [null, null, C] : [C ? w : Fo(F), F, C];
  }, oe = (w, C = !0, F) => {
    const [S, T, B] = Q(w);
    return S ? (F || o.nodes).filter((W) => {
      if (!B && (W.id === T.id || !W.computedPosition))
        return !1;
      const re = Fo(W), J = Wn(re, S);
      return C && J > 0 || J >= Number(w.width) * Number(w.height);
    }) : [];
  }, ne = (w, C, F = !0) => {
    const [S] = Q(w);
    if (!S)
      return !1;
    const T = Wn(S, C);
    return F && T > 0 || T >= Number(w.width) * Number(w.height);
  }, Y = (w) => {
    const { viewport: C, dimensions: F, d3Zoom: S, d3Selection: T, translateExtent: B } = o;
    if (!S || !T || !w.x && !w.y)
      return !1;
    const W = _t.translate(C.x + w.x, C.y + w.y).scale(C.zoom), re = [
      [0, 0],
      [F.width, F.height]
    ], J = S.constrain()(W, re, B), ce = o.viewport.x !== J.x || o.viewport.y !== J.y || o.viewport.zoom !== J.k;
    return S.transform(T, J), ce;
  }, ie = (w) => {
    const C = w instanceof Function ? w(o) : w, F = [
      "modelValue",
      "nodes",
      "edges",
      "maxZoom",
      "minZoom",
      "translateExtent",
      "nodeExtent",
      "hooks",
      "defaultEdgeOptions"
    ], S = [
      "d3Zoom",
      "d3Selection",
      "d3ZoomHandler",
      "viewportRef",
      "vueFlowRef",
      "dimensions",
      "hooks"
    ];
    he(C.defaultEdgeOptions) && (o.defaultEdgeOptions = C.defaultEdgeOptions);
    const T = C.modelValue || C.nodes || C.edges ? [] : void 0;
    T && (C.modelValue && T.push(...C.modelValue), C.nodes && T.push(...C.nodes), C.edges && T.push(...C.edges), E(T));
    const B = () => {
      he(C.maxZoom) && I(C.maxZoom), he(C.minZoom) && H(C.minZoom), he(C.translateExtent) && Z(C.translateExtent), he(C.nodeExtent) && ee(C.nodeExtent);
    };
    Object.keys(C).forEach((W) => {
      const re = W, J = C[re];
      ![...F, ...S].includes(re) && he(J) && (o[re] = J);
    }), o.d3Zoom ? B() : Ze(() => o.d3Zoom).not.toBeUndefined().then(B), o.initialized || (o.initialized = !0);
  }, Ye = {
    updateNodePositions: N,
    updateNodeDimensions: f,
    setElements: E,
    setNodes: m,
    setEdges: k,
    addNodes: O,
    addEdges: z,
    removeNodes: G,
    removeEdges: P,
    findNode: h,
    findEdge: p,
    updateEdge: U,
    applyEdgeChanges: L,
    applyNodeChanges: K,
    addSelectedElements: M,
    addSelectedNodes: b,
    addSelectedEdges: y,
    setMinZoom: H,
    setMaxZoom: I,
    setTranslateExtent: Z,
    setNodeExtent: ee,
    removeSelectedElements: V,
    removeSelectedNodes: x,
    removeSelectedEdges: D,
    startConnection: j,
    updateConnection: $,
    endConnection: te,
    setInteractive: X,
    setState: ie,
    getIntersectingNodes: oe,
    getIncomers: u,
    getOutgoers: c,
    getConnectedEdges: d,
    isNodeIntersecting: ne,
    panBy: Y,
    fitView: (w) => a.value.fitView(w),
    zoomIn: (w) => a.value.zoomIn(w),
    zoomOut: (w) => a.value.zoomOut(w),
    zoomTo: (w, C) => a.value.zoomTo(w, C),
    setViewport: (w, C) => a.value.setViewport(w, C),
    setTransform: (w, C) => a.value.setTransform(w, C),
    getViewport: () => a.value.getViewport(),
    getTransform: () => a.value.getTransform(),
    setCenter: (w, C, F) => a.value.setCenter(w, C, F),
    fitBounds: (w, C) => a.value.fitBounds(w, C),
    project: (w) => a.value.project(w),
    toObject: () => JSON.parse(
      JSON.stringify({
        nodes: o.nodes.map((w) => {
          const {
            computedPosition: C,
            handleBounds: F,
            selected: S,
            dimensions: T,
            isParent: B,
            resizing: W,
            dragging: re,
            initialized: J,
            ...ce
          } = w;
          return ce;
        }),
        edges: o.edges.map((w) => {
          const { selected: C, sourceNode: F, targetNode: S, ...T } = w;
          return T;
        }),
        position: [o.viewport.x, o.viewport.y],
        zoom: o.viewport.zoom,
        viewport: o.viewport
      })
    ),
    fromObject: (w) => {
      const { nodes: C, edges: F, position: S, zoom: T, viewport: B } = w;
      if (C && m(C), F && k(F), B != null && B.x && (B != null && B.y) || S) {
        const W = (B == null ? void 0 : B.x) || S[0], re = (B == null ? void 0 : B.y) || S[1], J = (B == null ? void 0 : B.zoom) || T || o.viewport.zoom;
        Ze(() => a.value.initialized).toBe(!0).then(() => {
          a.value.setViewport({
            x: W,
            y: re,
            zoom: J
          });
        });
      }
    },
    updateNodeInternals: s,
    $reset: () => {
      const w = _r();
      if (o.edges = [], o.nodes = [], o.d3Zoom && o.d3Selection) {
        const C = _t.translate(w.defaultViewport.x ?? 0, w.defaultViewport.y ?? 0).scale(st(w.defaultViewport.zoom ?? 1, w.minZoom, w.maxZoom)), F = o.viewportRef.getBoundingClientRect(), S = [
          [0, 0],
          [F.width, F.height]
        ], T = o.d3Zoom.constrain()(C, S, w.translateExtent);
        o.d3Zoom.transform(o.d3Selection, T);
      }
      ie(w);
    },
    $destroy: () => {
    }
  };
  return Ze(() => a.value.initialized).toBe(!0, { flush: "pre" }).then(() => {
    o.fitViewOnInit && a.value.fitView(), o.hooks.paneReady.trigger({
      id: e,
      emits: t,
      vueFlowVersion: "1.23.0",
      ...n,
      ...o,
      ...i,
      ...Ye
    });
  }), Ye;
}
function od(e, t, n) {
  const o = le(() => (g) => e.nodes && !t.value.length ? e.nodes.find((_) => _.id === g) : e.nodes[t.value.indexOf(g)]), i = le(() => (g) => e.edges && !n.value.length ? e.edges.find((_) => _.id === g) : e.edges[n.value.indexOf(g)]), r = le(() => {
    var v;
    const g = {
      ...ed,
      ...e.edgeTypes
    }, _ = Object.keys(g);
    return (v = e.edges) == null || v.forEach((b) => b.type && !_.includes(b.type) && (g[b.type] = b.type)), g;
  }), l = le(() => {
    var v;
    const g = {
      ...Qc,
      ...e.nodeTypes
    }, _ = Object.keys(g);
    return (v = e.nodes) == null || v.forEach((b) => b.type && !_.includes(b.type) && (g[b.type] = b.type)), g;
  }), a = le(() => {
    const g = e.nodes.filter((_) => !_.hidden);
    return e.onlyRenderVisibleElements ? g && rr(
      g,
      {
        x: 0,
        y: 0,
        width: e.dimensions.width,
        height: e.dimensions.height
      },
      e.viewport,
      !0
    ) : g ?? [];
  }), s = (g, _, v) => {
    if (_ = _ ?? o.value(g.source), v = v ?? o.value(g.target), !_ || !v) {
      e.hooks.error.trigger(new Ee(_e.EDGE_ORPHANED, g.id));
      return;
    }
    return !g.hidden && !v.hidden && !_.hidden;
  }, u = le(() => e.onlyRenderVisibleElements ? e.edges.filter((g) => {
    const _ = o.value(g.source), v = o.value(g.target);
    return s(g, _, v) && tc({
      sourcePos: _.computedPosition || { x: 0, y: 0 },
      targetPos: v.computedPosition || { x: 0, y: 0 },
      sourceWidth: _.dimensions.width,
      sourceHeight: _.dimensions.height,
      targetWidth: v.dimensions.width,
      targetHeight: v.dimensions.height,
      width: e.dimensions.width,
      height: e.dimensions.height,
      viewport: e.viewport
    });
  }) : e.edges.filter((g) => s(g))), c = le(() => [...a.value, ...u.value]), d = le(() => e.nodes.filter((g) => g.selected)), h = le(() => e.edges.filter((g) => g.selected)), p = le(() => [
    ...d.value ?? [],
    ...h.value ?? []
  ]), N = le(
    () => a.value.filter((g) => g.initialized && g.handleBounds !== void 0)
  ), f = le(
    () => a.value.length > 0 && N.value.length === a.value.length
  );
  return {
    getNode: o,
    getEdge: i,
    getElements: c,
    getEdgeTypes: r,
    getNodeTypes: l,
    getEdges: u,
    getNodes: a,
    getSelectedElements: p,
    getSelectedNodes: d,
    getSelectedEdges: h,
    getNodesInitialized: N,
    areNodesInitialized: f
  };
}
class ft {
  constructor() {
    this.currentId = 0, this.flows = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    return ft.instance || (ft.instance = new ft()), ft.instance;
  }
  set(t, n) {
    return this.flows.set(t, n);
  }
  get(t) {
    return this.flows.get(t);
  }
  remove(t) {
    return this.flows.delete(t);
  }
  create(t, n) {
    const o = _r(n), i = Ir(o), r = {};
    Object.entries(i.hooks).forEach(([h, p]) => {
      const N = `on${h.charAt(0).toUpperCase() + h.slice(1)}`;
      r[N] = p.on;
    });
    const l = {};
    Object.entries(i.hooks).forEach(([h, p]) => {
      l[h] = p.trigger;
    });
    const a = le(() => i.nodes.map((h) => h.id)), s = le(() => i.edges.map((h) => h.id)), u = od(i, a, s), c = nd(t, l, r, i, u, a, s);
    c.setState(i);
    const d = {
      ...r,
      ...u,
      ...c,
      ...Xr(i),
      emits: l,
      id: t,
      vueFlowVersion: "1.23.0",
      $destroy: () => {
        this.remove(t);
      }
    };
    return this.set(t, d), d;
  }
  getId() {
    return `vue-flow-${this.currentId++}`;
  }
}
function ye(e) {
  const t = ft.getInstance(), n = di(), o = e == null ? void 0 : e.id, i = (n == null ? void 0 : n.vueFlowId) || o;
  let r;
  if (n) {
    const l = qe(ti, null);
    typeof l < "u" && l !== null && (r = l);
  }
  if (r || i && (r = t.get(i)), !r || r && o && o !== r.id) {
    const l = o ?? t.getId(), a = t.create(l, e);
    r = a, vi().run(() => {
      pe(
        a.applyDefault,
        (u) => {
          const c = (h) => {
            a.applyNodeChanges(h);
          }, d = (h) => {
            a.applyEdgeChanges(h);
          };
          u ? (a.onNodesChange(c), a.onEdgesChange(d)) : (a.hooks.value.nodesChange.off(c), a.hooks.value.edgesChange.off(d));
        },
        { immediate: !0 }
      ), Bt(() => {
        if (r) {
          const u = t.get(r.id);
          u ? u.$destroy() : zt(`No store instance found for id ${r.id} in storage.`);
        }
      });
    });
  } else
    e && r.setState(e);
  return n && (mt(ti, r), n.vueFlowId = r.id), r;
}
function Ud(e) {
  const t = e ?? qe(gr, ""), n = qe(vr, ue(null)), { findEdge: o, emits: i } = ye(), r = o(t);
  return r || i.error(new Ee(_e.EDGE_NOT_FOUND, t)), {
    id: t,
    edge: r,
    edgeEl: n
  };
}
function id() {
  return {
    doubleClick: R(),
    click: R(),
    mouseEnter: R(),
    mouseMove: R(),
    mouseLeave: R(),
    contextMenu: R(),
    updateStart: R(),
    update: R(),
    updateEnd: R()
  };
}
function rd(e, t) {
  const n = id();
  return n.doubleClick.on((o) => {
    var i, r;
    t.edgeDoubleClick(o), (r = (i = e.events) == null ? void 0 : i.doubleClick) == null || r.call(i, o);
  }), n.click.on((o) => {
    var i, r;
    t.edgeClick(o), (r = (i = e.events) == null ? void 0 : i.click) == null || r.call(i, o);
  }), n.mouseEnter.on((o) => {
    var i, r;
    t.edgeMouseEnter(o), (r = (i = e.events) == null ? void 0 : i.mouseEnter) == null || r.call(i, o);
  }), n.mouseMove.on((o) => {
    var i, r;
    t.edgeMouseMove(o), (r = (i = e.events) == null ? void 0 : i.mouseMove) == null || r.call(i, o);
  }), n.mouseLeave.on((o) => {
    var i, r;
    t.edgeMouseLeave(o), (r = (i = e.events) == null ? void 0 : i.mouseLeave) == null || r.call(i, o);
  }), n.contextMenu.on((o) => {
    var i, r;
    t.edgeContextMenu(o), (r = (i = e.events) == null ? void 0 : i.contextMenu) == null || r.call(i, o);
  }), n.updateStart.on((o) => {
    var i, r;
    t.edgeUpdateStart(o), (r = (i = e.events) == null ? void 0 : i.updateStart) == null || r.call(i, o);
  }), n.update.on((o) => {
    var i, r;
    t.edgeUpdate(o), (r = (i = e.events) == null ? void 0 : i.update) == null || r.call(i, o);
  }), n.updateEnd.on((o) => {
    var i, r;
    t.edgeUpdateEnd(o), (r = (i = e.events) == null ? void 0 : i.updateEnd) == null || r.call(i, o);
  }), Object.entries(n).reduce(
    (o, [i, r]) => (o.emit[i] = r.trigger, o.on[i] = r.on, o),
    { emit: {}, on: {} }
  );
}
function ld() {
  const { viewport: e, snapGrid: t, snapToGrid: n } = ye();
  return ({ sourceEvent: o }) => {
    const i = o.touches ? o.touches[0].clientX : o.clientX, r = o.touches ? o.touches[0].clientY : o.clientY, l = {
      x: (i - e.value.x) / e.value.zoom,
      y: (r - e.value.y) / e.value.zoom
    };
    return {
      xSnapped: n.value ? t.value[0] * Math.round(l.x / t.value[0]) : l.x,
      ySnapped: n.value ? t.value[1] * Math.round(l.y / t.value[1]) : l.y,
      ...l
    };
  };
}
function Ut() {
  return !0;
}
function br({
  handleId: e,
  nodeId: t,
  type: n,
  isValidConnection: o,
  edgeUpdaterType: i,
  onEdgeUpdate: r,
  onEdgeUpdateEnd: l
}) {
  const {
    vueFlowRef: a,
    connectionMode: s,
    connectionRadius: u,
    connectOnClick: c,
    connectionClickStartHandle: d,
    nodesConnectable: h,
    autoPanOnConnect: p,
    findNode: N,
    panBy: f,
    getNodes: g,
    startConnection: _,
    updateConnection: v,
    endConnection: b,
    emits: y,
    viewport: M,
    edges: x,
    isValidConnection: D
  } = ye();
  let V = null, H = !1, I = null;
  function Z(X) {
    var O;
    const m = se(n) === "target", k = fo(X), E = Go(X.target);
    if (k && X.button === 0 || !k) {
      let z = function(we) {
        Y = ot(we, oe);
        const { handle: Ye, validHandleResult: w } = oc(
          we,
          E,
          qn(Y, M.value, !1, [1, 1]),
          u.value,
          ge,
          (C) => Jo(
            we,
            C,
            s.value,
            se(t),
            se(e),
            m ? "target" : "source",
            U,
            E,
            x.value,
            N
          )
        );
        if (K = Ye, ie || (xe(), ie = !0), V = w.connection, H = w.isValid, I = w.handleDomNode, v(
          K && H ? tr(
            {
              x: K.x,
              y: K.y
            },
            M.value
          ) : Y,
          w.endHandle,
          rc(!!K, H)
        ), !K && !H && !I)
          return In(ne);
        V && V.source !== V.target && I && (In(ne), ne = I, I.classList.add("connecting", "vue-flow__handle-connecting"), I.classList.toggle("valid", H), I.classList.toggle("vue-flow__handle-valid", H));
      }, G = function(we) {
        (K || I) && V && H && (r ? r(we, V) : y.connect(V)), y.connectEnd(we), i && (l == null || l(we)), In(ne), cancelAnimationFrame(L), b(we), ie = !1, H = !1, V = null, I = null, E.removeEventListener("mousemove", z), E.removeEventListener("mouseup", G), E.removeEventListener("touchmove", z), E.removeEventListener("touchend", G);
      };
      const P = N(se(t));
      let U = se(o) || D.value || Ut;
      !U && P && (U = (m ? P.isValidSourcePos : P.isValidTargetPos) || Ut);
      let K, L = 0;
      const { x: j, y: $ } = ot(X), te = E == null ? void 0 : E.elementFromPoint(j, $), Q = ho(se(i), te), oe = (O = a.value) == null ? void 0 : O.getBoundingClientRect();
      if (!oe || !Q)
        return;
      let ne, Y = ot(X, oe), ie = !1;
      const ge = ic({
        nodes: g.value,
        nodeId: se(t),
        handleId: se(e),
        handleType: Q
      }), xe = () => {
        if (!p)
          return;
        const [we, Ye] = ar(Y, oe);
        f({ x: we, y: Ye }), L = requestAnimationFrame(xe);
      };
      _(
        {
          nodeId: se(t),
          handleId: se(e),
          type: Q
        },
        {
          x: j - oe.left,
          y: $ - oe.top
        },
        X
      ), y.connectStart({ event: X, nodeId: se(t), handleId: se(e), handleType: Q }), E.addEventListener("mousemove", z), E.addEventListener("mouseup", G), E.addEventListener("touchmove", z), E.addEventListener("touchend", G);
    }
  }
  function ee(X) {
    if (!c.value)
      return;
    const m = se(n) === "target";
    if (!d.value)
      y.clickConnectStart({ event: X, nodeId: se(t), handleId: se(e) }), _({ nodeId: se(t), type: se(n), handleId: se(e) }, void 0, X, !0);
    else {
      let k = se(o) || D.value || Ut;
      const E = N(se(t));
      if (!k && E && (k = (m ? E.isValidSourcePos : E.isValidTargetPos) || Ut), E && (typeof E.connectable > "u" ? h.value : E.connectable) === !1)
        return;
      const O = Go(X.target), { connection: z, isValid: G } = Jo(
        X,
        {
          nodeId: se(t),
          id: se(e),
          type: se(n)
        },
        s.value,
        d.value.nodeId,
        d.value.handleId || null,
        d.value.type,
        k,
        O,
        x.value,
        N
      ), P = z.source === z.target;
      G && !P && y.connect(z), y.clickConnectEnd(X), b(X, !0);
    }
  }
  return {
    handlePointerDown: Z,
    handleClick: ee
  };
}
function vo() {
  return typeof window < "u" ? window : { chrome: !1 };
}
function Qn(e) {
  var i, r;
  const t = ((r = (i = e.composedPath) == null ? void 0 : i.call(e)) == null ? void 0 : r[0]) || e.target, n = bt(t.hasAttribute) ? t.hasAttribute("contenteditable") : !1, o = bt(t.closest) ? t.closest(".nokey") : null;
  return ["INPUT", "SELECT", "TEXTAREA"].includes(t == null ? void 0 : t.nodeName) || n || !!o;
}
function ad(e) {
  return e.ctrlKey || e.metaKey || e.shiftKey;
}
function ai(e, t, n, o) {
  const i = t.split("+").map((r) => r.trim().toLowerCase());
  return i.length === 1 ? e === t : (o ? n.delete(e.toLowerCase()) : n.add(e.toLowerCase()), i.every(
    (r, l) => n.has(r) && Array.from(n.values())[l] === i[l]
  ));
}
function sd(e, t) {
  return (n) => Array.isArray(e) ? e.some((o) => ai(n.key, o, t, n.type === "keyup")) : ai(n.key, e, t, n.type === "keyup");
}
function $t(e, t) {
  const n = vo(), o = ue(se(e) === !0);
  let i = !1;
  const r = /* @__PURE__ */ new Set();
  return pe(o, () => {
    t == null || t(o.value);
  }), pe(
    () => se(e),
    (a, s) => {
      if (n && typeof n.addEventListener < "u" && to(n, "blur", () => {
        o.value = !1;
      }), On(s) && !On(a) && l(), a === null) {
        l();
        return;
      }
      if (On(a)) {
        o.value = a;
        return;
      }
      (Array.isArray(a) || Me(a) && a.includes("+")) && (a = sd(a, r)), a && (bo(
        a,
        (u) => {
          i = ad(u), !(!i && Qn(u)) && (u.preventDefault(), o.value = !0);
        },
        { eventName: "keydown" }
      ), bo(
        a,
        (u) => {
          if (o.value) {
            if (!i && Qn(u))
              return;
            l();
          }
        },
        { eventName: "keyup" }
      ));
    },
    {
      immediate: !0
    }
  ), o;
  function l() {
    i = !1, r.clear(), o.value = !1;
  }
}
function ud(e) {
  const t = e ?? qe(fr, ""), n = qe(hr, ue(null)), { findNode: o, edges: i, emits: r } = ye(), l = o(t);
  return l || r.error(new Ee(_e.NODE_NOT_FOUND, t)), {
    id: t,
    nodeEl: n,
    node: l,
    parentNode: le(() => o(l.parentNode)),
    connectedEdges: le(() => yn([l], i.value))
  };
}
function cd() {
  return {
    doubleClick: R(),
    click: R(),
    mouseEnter: R(),
    mouseMove: R(),
    mouseLeave: R(),
    contextMenu: R(),
    dragStart: R(),
    drag: R(),
    dragStop: R()
  };
}
function dd(e, t) {
  const n = cd();
  return n.doubleClick.on((o) => {
    var i, r;
    t.nodeDoubleClick(o), (r = (i = e.events) == null ? void 0 : i.doubleClick) == null || r.call(i, o);
  }), n.click.on((o) => {
    var i, r;
    t.nodeClick(o), (r = (i = e.events) == null ? void 0 : i.click) == null || r.call(i, o);
  }), n.mouseEnter.on((o) => {
    var i, r;
    t.nodeMouseEnter(o), (r = (i = e.events) == null ? void 0 : i.mouseEnter) == null || r.call(i, o);
  }), n.mouseMove.on((o) => {
    var i, r;
    t.nodeMouseMove(o), (r = (i = e.events) == null ? void 0 : i.mouseMove) == null || r.call(i, o);
  }), n.mouseLeave.on((o) => {
    var i, r;
    t.nodeMouseLeave(o), (r = (i = e.events) == null ? void 0 : i.mouseLeave) == null || r.call(i, o);
  }), n.contextMenu.on((o) => {
    var i, r;
    t.nodeContextMenu(o), (r = (i = e.events) == null ? void 0 : i.contextMenu) == null || r.call(i, o);
  }), n.dragStart.on((o) => {
    var i, r;
    t.nodeDragStart(o), (r = (i = e.events) == null ? void 0 : i.dragStart) == null || r.call(i, o);
  }), n.drag.on((o) => {
    var i, r;
    t.nodeDrag(o), (r = (i = e.events) == null ? void 0 : i.drag) == null || r.call(i, o);
  }), n.dragStop.on((o) => {
    var i, r;
    t.nodeDragStop(o), (r = (i = e.events) == null ? void 0 : i.dragStop) == null || r.call(i, o);
  }), Object.entries(n).reduce(
    (o, [i, r]) => (o.emit[i] = r.trigger, o.on[i] = r.on, o),
    { emit: {}, on: {} }
  );
}
function Er() {
  const { getSelectedNodes: e, nodeExtent: t, updateNodePositions: n, findNode: o, snapGrid: i, snapToGrid: r, nodesDraggable: l, emits: a } = ye();
  return (s, u = !1) => {
    const c = r.value ? i.value[0] : 5, d = r.value ? i.value[1] : 5, h = u ? 4 : 1, p = s.x * c * h, N = s.y * d * h, f = e.value.filter((g) => g.draggable || l && typeof g.draggable > "u").map((g) => {
      const _ = { x: g.computedPosition.x + p, y: g.computedPosition.y + N }, { computedPosition: v } = co(
        g,
        _,
        a.error,
        t.value,
        g.parentNode ? o(g.parentNode) : void 0
      );
      return {
        id: g.id,
        position: v,
        from: g.position,
        distance: { x: s.x, y: s.y },
        dimensions: g.dimensions
      };
    });
    n(f, !0, !1);
  };
}
const An = 0.1;
function Xe() {
  return Promise.resolve(!1);
}
const fd = {
  zoomIn: Xe,
  zoomOut: Xe,
  zoomTo: Xe,
  fitView: Xe,
  setCenter: Xe,
  fitBounds: Xe,
  project: (e) => e,
  screenToFlowCoordinate: (e) => e,
  flowToScreenCoordinate: (e) => e,
  setViewport: Xe,
  setTransform: Xe,
  getViewport: () => ({ x: 0, y: 0, zoom: 1 }),
  getTransform: () => ({ x: 0, y: 0, zoom: 1 }),
  initialized: !1
};
function Sr(e, t) {
  const n = e, o = me(n, "vueFlowRef"), i = me(n, "nodes"), r = me(n, "d3Zoom"), l = me(n, "d3Selection"), a = me(n, "dimensions"), s = me(n, "translateExtent"), u = me(n, "minZoom"), c = me(n, "maxZoom"), d = me(n, "viewport"), h = me(n, "snapToGrid"), p = me(n, "snapGrid"), { getNodes: N } = t, f = ue(!1);
  Ze(() => !!r.value && !!l.value && !!a.value.width && !!a.value.height).toBe(!0).then(() => {
    f.value = !0;
  });
  function g(v, b) {
    return new Promise((y) => {
      l.value && r.value ? r.value.scaleBy(
        Dn(l.value, b, () => {
          y(!0);
        }),
        v
      ) : y(!1);
    });
  }
  function _(v, b, y, M) {
    return new Promise((x) => {
      const { x: D, y: V } = Ji({ x: -v, y: -b }, s.value), H = _t.translate(-D, -V).scale(y);
      l.value && r.value ? r.value.transform(
        Dn(l.value, M, () => {
          x(!0);
        }),
        H
      ) : x(!1);
    });
  }
  return le(() => f.value ? {
    initialized: !0,
    // todo: allow passing scale as option
    zoomIn: (v) => g(1.2, v == null ? void 0 : v.duration),
    zoomOut: (v) => g(1 / 1.2, v == null ? void 0 : v.duration),
    zoomTo: (v, b) => new Promise((y) => {
      l.value && r.value ? r.value.scaleTo(
        Dn(l.value, b == null ? void 0 : b.duration, () => {
          y(!0);
        }),
        v
      ) : y(!1);
    }),
    setViewport: (v, b) => _(v.x, v.y, v.zoom, b == null ? void 0 : b.duration),
    setTransform: (v, b) => _(v.x, v.y, v.zoom, b == null ? void 0 : b.duration),
    getViewport: () => ({
      x: d.value.x,
      y: d.value.y,
      zoom: d.value.zoom
    }),
    getTransform: () => ({
      x: d.value.x,
      y: d.value.y,
      zoom: d.value.zoom
    }),
    fitView: (v = {
      padding: An,
      includeHiddenNodes: !1,
      duration: 0
    }) => {
      const b = (v.includeHiddenNodes ? i.value : N.value).filter((V) => {
        var Z;
        const H = V.initialized && V.dimensions.width && V.dimensions.height;
        let I = !0;
        return (Z = v.nodes) != null && Z.length && (I = v.nodes.includes(V.id)), H && I;
      });
      if (!b.length)
        return Promise.resolve(!1);
      const y = ir(b), { x: M, y: x, zoom: D } = Yo(
        y,
        a.value.width,
        a.value.height,
        v.minZoom ?? u.value,
        v.maxZoom ?? c.value,
        v.padding ?? An,
        v.offset
      );
      return _(M, x, D, v == null ? void 0 : v.duration);
    },
    setCenter: (v, b, y) => {
      const M = typeof (y == null ? void 0 : y.zoom) < "u" ? y.zoom : c.value, x = a.value.width / 2 - v * M, D = a.value.height / 2 - b * M;
      return _(x, D, M, y == null ? void 0 : y.duration);
    },
    fitBounds: (v, b = { padding: An }) => {
      const { x: y, y: M, zoom: x } = Yo(
        v,
        a.value.width,
        a.value.height,
        u.value,
        c.value,
        b.padding
      );
      return _(y, M, x, b == null ? void 0 : b.duration);
    },
    project: (v) => qn(v, d.value, h.value, p.value),
    screenToFlowCoordinate: (v) => {
      if (o.value) {
        const { x: b, y } = o.value.getBoundingClientRect(), M = {
          x: v.x - b,
          y: v.y - y
        };
        return qn(M, d.value, h.value, p.value);
      }
      return { x: 0, y: 0 };
    },
    flowToScreenCoordinate: (v) => {
      if (o.value) {
        const { x: b, y } = o.value.getBoundingClientRect(), M = {
          x: v.x + b,
          y: v.y + y
        };
        return tr(M, d.value);
      }
      return { x: 0, y: 0 };
    }
  } : fd);
}
function Dn(e, t = 0, n) {
  return e.transition().duration(t).on("end", n);
}
function hd(e, t, n) {
  const o = vi();
  return o.run(() => {
    const i = () => {
      o.run(() => {
        let f, g, _ = !!(n.nodes.value.length || n.edges.value.length);
        f = ut([e.modelValue, () => {
          var v, b;
          return (b = (v = e.modelValue) == null ? void 0 : v.value) == null ? void 0 : b.length;
        }], ([v]) => {
          v && Array.isArray(v) && (g == null || g.pause(), n.setElements(v), !g && !_ && v.length ? _ = !0 : g == null || g.resume());
        }), g = ut(
          [n.nodes, n.edges, () => n.edges.value.length, () => n.nodes.value.length],
          ([v, b]) => {
            var y;
            (y = e.modelValue) != null && y.value && Array.isArray(e.modelValue.value) && (f == null || f.pause(), e.modelValue.value = [...v, ...b], et(() => {
              f == null || f.resume();
            }));
          },
          { immediate: _ }
        ), Zt(() => {
          f == null || f.stop(), g == null || g.stop();
        });
      });
    }, r = () => {
      o.run(() => {
        let f, g, _ = !!n.nodes.value.length;
        f = ut([e.nodes, () => {
          var v, b;
          return (b = (v = e.nodes) == null ? void 0 : v.value) == null ? void 0 : b.length;
        }], ([v]) => {
          v && Array.isArray(v) && (g == null || g.pause(), n.setNodes(v), !g && !_ && v.length ? _ = !0 : g == null || g.resume());
        }), g = ut(
          [n.nodes, () => n.nodes.value.length],
          ([v]) => {
            var b;
            (b = e.nodes) != null && b.value && Array.isArray(e.nodes.value) && (f == null || f.pause(), e.nodes.value = [...v], et(() => {
              f == null || f.resume();
            }));
          },
          { immediate: _ }
        ), Zt(() => {
          f == null || f.stop(), g == null || g.stop();
        });
      });
    }, l = () => {
      o.run(() => {
        let f, g, _ = !!n.edges.value.length;
        f = ut([e.edges, () => {
          var v, b;
          return (b = (v = e.edges) == null ? void 0 : v.value) == null ? void 0 : b.length;
        }], ([v]) => {
          v && Array.isArray(v) && (g == null || g.pause(), n.setEdges(v), !g && !_ && v.length ? _ = !0 : g == null || g.resume());
        }), g = ut(
          [n.edges, () => n.edges.value.length],
          ([v]) => {
            var b;
            (b = e.edges) != null && b.value && Array.isArray(e.edges.value) && (f == null || f.pause(), e.edges.value = [...v], et(() => {
              f == null || f.resume();
            }));
          },
          { immediate: _ }
        ), Zt(() => {
          f == null || f.stop(), g == null || g.stop();
        });
      });
    }, a = () => {
      o.run(() => {
        pe(
          () => t.maxZoom,
          () => {
            t.maxZoom && he(t.maxZoom) && n.setMaxZoom(t.maxZoom);
          }
        );
      });
    }, s = () => {
      o.run(() => {
        pe(
          () => t.minZoom,
          () => {
            t.minZoom && he(t.minZoom) && n.setMinZoom(t.minZoom);
          }
        );
      });
    }, u = () => {
      o.run(() => {
        pe(
          () => t.translateExtent,
          () => {
            t.translateExtent && he(t.translateExtent) && n.setTranslateExtent(t.translateExtent);
          }
        );
      });
    }, c = () => {
      o.run(() => {
        pe(
          () => t.nodeExtent,
          () => {
            t.nodeExtent && he(t.nodeExtent) && n.setNodeExtent(t.nodeExtent);
          }
        );
      });
    }, d = () => {
      o.run(() => {
        pe(
          () => t.applyDefault,
          () => {
            he(t.applyDefault) && (n.applyDefault.value = t.applyDefault);
          }
        );
      });
    }, h = () => {
      o.run(() => {
        const f = async (g) => {
          let _ = g;
          bt(t.autoConnect) && (_ = await t.autoConnect(g)), _ !== !1 && n.addEdges([_]);
        };
        pe(
          () => t.autoConnect,
          () => {
            he(t.autoConnect) && (n.autoConnect.value = t.autoConnect);
          }
        ), pe(
          n.autoConnect,
          (g, _, v) => {
            g ? n.onConnect(f) : n.hooks.value.connect.off(f), v(() => {
              n.hooks.value.connect.off(f);
            });
          },
          { immediate: !0 }
        );
      });
    }, p = () => {
      const f = [
        "id",
        "modelValue",
        "translateExtent",
        "nodeExtent",
        "edges",
        "nodes",
        "maxZoom",
        "minZoom",
        "applyDefault",
        "autoConnect"
      ];
      Object.keys(t).forEach((g) => {
        if (!f.includes(g)) {
          const _ = Jt(t, g), v = n[g];
          o.run(() => {
            pe(
              _,
              (b) => {
                he(b) && (v.value = b);
              },
              { flush: "pre" }
            );
          });
        }
      });
    };
    (() => {
      i(), r(), l(), s(), a(), u(), c(), d(), h(), p();
    })();
  }), () => o.stop();
}
function Zd(e) {
  const t = ye({ id: e }), n = Sr(t.value, t.value);
  return {
    fitView: (o) => n.value.fitView(o),
    zoomIn: (o) => n.value.zoomIn(o),
    zoomOut: (o) => n.value.zoomOut(o),
    zoomTo: (o, i) => n.value.zoomTo(o, i),
    setViewport: (o, i) => n.value.setViewport(o, i),
    setTransform: (o, i) => n.value.setTransform(o, i),
    getViewport: () => n.value.getViewport(),
    getTransform: () => n.value.getTransform(),
    setCenter: (o, i, r) => n.value.setCenter(o, i, r),
    fitBounds: (o, i) => n.value.fitBounds(o, i),
    project: (o) => n.value.project(o)
  };
}
function si(e, t) {
  return {
    x: e.clientX - t.left,
    y: e.clientY - t.top
  };
}
const gd = {
  name: "Pane",
  compatConfig: { MODE: 3 }
}, vd = /* @__PURE__ */ ve({
  ...gd,
  props: {
    isSelecting: { type: Boolean }
  },
  setup(e) {
    const {
      id: t,
      vueFlowRef: n,
      getNodes: o,
      getEdges: i,
      viewport: r,
      emits: l,
      userSelectionActive: a,
      removeSelectedElements: s,
      panOnDrag: u,
      userSelectionRect: c,
      elementsSelectable: d,
      nodesSelectionActive: h,
      addSelectedElements: p,
      getSelectedEdges: N,
      getSelectedNodes: f,
      removeNodes: g,
      removeEdges: _,
      selectionMode: v,
      deleteKeyCode: b,
      multiSelectionKeyCode: y,
      multiSelectionActive: M
    } = ye(), x = ue(null), D = ue(0), V = ue(0), H = ue(), I = le(() => d.value && (e.isSelecting || a.value));
    $t(b, (P) => {
      if (!P)
        return;
      const U = o.value.reduce((K, L) => ((!L.selected && L.parentNode && K.find((j) => j.id === L.parentNode) || L.selected) && K.push(L), K), []);
      (U || N.value) && (N.value.length > 0 && _(N.value), U.length > 0 && g(U), h.value = !1, s());
    }), $t(y, (P) => {
      M.value = P;
    });
    function Z() {
      a.value = !1, c.value = null, D.value = 0, V.value = 0;
    }
    function ee(P) {
      P.target !== x.value || I.value || (l.paneClick(P), s(), h.value = !1);
    }
    function X(P) {
      var U;
      if (P.target === x.value) {
        if (Array.isArray(u.value) && ((U = u.value) != null && U.includes(2))) {
          P.preventDefault();
          return;
        }
        l.paneContextMenu(P);
      }
    }
    function m(P) {
      P.target === x.value && l.paneScroll(P);
    }
    function k(P) {
      if (H.value = n.value.getBoundingClientRect(), !I.value || !d || !e.isSelecting || P.button !== 0 || P.target !== x.value || !H.value)
        return;
      const { x: U, y: K } = si(P, H.value);
      s(), c.value = {
        width: 0,
        height: 0,
        startX: U,
        startY: K,
        x: U,
        y: K
      }, a.value = !0, l.selectionStart(P);
    }
    function E(P) {
      if (!I.value)
        return l.paneMouseMove(P);
      if (!e.isSelecting || !H.value || !c.value)
        return;
      a.value || (a.value = !0), h.value && (h.value = !1);
      const U = si(P, H.value), K = c.value.startX ?? 0, L = c.value.startY ?? 0, j = {
        ...c.value,
        x: U.x < K ? U.x : K,
        y: U.y < L ? U.y : L,
        width: Math.abs(U.x - K),
        height: Math.abs(U.y - L)
      }, $ = rr(
        o.value,
        c.value,
        r.value,
        v.value === so.Partial
      ), te = yn($, i.value);
      D.value = $.length, V.value = te.length, c.value = j, p([...$, ...te]);
    }
    function O(P) {
      I.value && P.button === 0 && (!a.value && c.value && P.target === x.value && ee(P), h.value = D.value > 0, Z(), l.selectionEnd(P));
    }
    function z(P) {
      var U;
      if (!I.value)
        return l.paneMouseLeave(P);
      a.value && (h.value = D.value > 0, (U = l.selectionEnd) == null || U.call(l, P)), Z();
    }
    function G(P) {
      I.value || l.paneMouseEnter(P);
    }
    return (P, U) => (ae(), de("div", {
      ref_key: "container",
      ref: x,
      key: `pane-${A(t)}`,
      class: it(["vue-flow__pane vue-flow__container", { selection: e.isSelecting }]),
      onClick: ee,
      onContextmenu: X,
      onWheelPassive: m,
      onMouseenter: G,
      onMousedown: k,
      onMousemove: E,
      onMouseup: O,
      onMouseleave: z
    }, [
      Ne(P.$slots, "default"),
      A(a) && A(c) ? (ae(), rt(Jc, {
        key: 0,
        "user-selection-rect": A(c)
      }, null, 8, ["user-selection-rect"])) : Te("", !0),
      A(h) && A(f).length ? (ae(), rt(Kc, { key: 1 })) : Te("", !0)
    ], 34));
  }
}), pd = { class: "vue-flow__nodes vue-flow__container" }, md = {
  name: "Nodes",
  compatConfig: { MODE: 3 }
}, yd = /* @__PURE__ */ ve({
  ...md,
  setup(e) {
    const t = qe(bn), {
      nodesDraggable: n,
      nodesFocusable: o,
      elementsSelectable: i,
      nodesConnectable: r,
      getNodes: l,
      getNodesInitialized: a,
      areNodesInitialized: s,
      getNodeTypes: u,
      updateNodeDimensions: c,
      emits: d
    } = ye(), h = ue(), p = dn();
    Ze(() => s.value).toBe(!0).then(() => {
      et(() => {
        d.nodesInitialized(a.value);
      });
    }), We(() => {
      h.value = new ResizeObserver((b) => {
        const y = b.map((M) => ({
          id: M.target.getAttribute("data-id"),
          nodeElement: M.target,
          forceUpdate: !0
        }));
        et(() => c(y));
      });
    }), gi(() => {
      var b;
      return (b = h.value) == null ? void 0 : b.disconnect();
    });
    function N(b) {
      return typeof b > "u" ? n.value : b;
    }
    function f(b) {
      return typeof b > "u" ? i.value : b;
    }
    function g(b) {
      return typeof b > "u" ? r.value : b;
    }
    function _(b) {
      return typeof b > "u" ? o.value : b;
    }
    function v(b, y) {
      const M = b || "default", x = t == null ? void 0 : t[`node-${M}`];
      if (x)
        return x;
      let D = y ?? u.value[M];
      if (typeof D == "string" && p) {
        const V = Object.keys(p.appContext.components);
        V && V.includes(M) && (D = pi(M, !1));
      }
      return D && typeof D != "string" ? D : (d.error(new Ee(_e.NODE_TYPE_MISSING, D)), !1);
    }
    return (b, y) => (ae(), de("div", pd, [
      h.value ? (ae(!0), de(ze, { key: 0 }, Tt(A(l), (M) => (ae(), rt(A(mc), {
        id: M.id,
        key: M.id,
        "resize-observer": h.value,
        type: v(M.type, M.template),
        name: M.type || "default",
        draggable: N(M.draggable),
        selectable: f(M.selectable),
        connectable: g(M.connectable),
        focusable: _(M.focusable),
        node: M
      }, null, 8, ["id", "resize-observer", "type", "name", "draggable", "selectable", "connectable", "focusable", "node"]))), 128)) : Te("", !0)
    ]));
  }
}), xd = ["id", "markerWidth", "markerHeight", "markerUnits", "orient"], wd = {
  name: "MarkerType",
  compatConfig: { MODE: 3 }
}, _d = /* @__PURE__ */ ve({
  ...wd,
  props: {
    id: null,
    type: null,
    color: { default: "none" },
    width: { default: 12.5 },
    height: { default: 12.5 },
    markerUnits: { default: "strokeWidth" },
    orient: { default: "auto-start-reverse" },
    strokeWidth: { default: 1 }
  },
  setup(e) {
    return (t, n) => (ae(), de("marker", {
      id: e.id,
      class: "vue-flow__arrowhead",
      viewBox: "-10 -10 20 20",
      refX: "0",
      refY: "0",
      markerWidth: `${e.width}`,
      markerHeight: `${e.height}`,
      markerUnits: e.markerUnits,
      orient: e.orient
    }, [
      e.type === A(Zn).ArrowClosed ? (ae(), de("polyline", {
        key: 0,
        style: De({
          stroke: e.color,
          fill: e.color,
          strokeWidth: e.strokeWidth
        }),
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        points: "-5,-4 0,0 -5,4 -5,-4"
      }, null, 4)) : Te("", !0),
      e.type === A(Zn).Arrow ? (ae(), de("polyline", {
        key: 1,
        style: De({
          stroke: e.color,
          strokeWidth: e.strokeWidth
        }),
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        fill: "none",
        points: "-5,-4 0,0 -5,4"
      }, null, 4)) : Te("", !0)
    ], 8, xd));
  }
}), bd = {
  name: "MarkerDefinitions",
  compatConfig: { MODE: 3 }
}, Ed = /* @__PURE__ */ ve({
  ...bd,
  setup(e) {
    const t = ye(), n = me(t, "id"), o = me(t, "edges"), i = me(t, "connectionLineOptions"), r = me(t, "defaultMarkerColor"), l = le(() => {
      const a = [], s = [], u = (c) => {
        if (c) {
          const d = Qe(c, n.value);
          a.includes(d) || (typeof c == "object" ? s.push({ ...c, id: d, color: c.color || r.value }) : s.push({ id: d, color: r.value, type: c }), a.push(d));
        }
      };
      return [i.value.markerEnd, i.value.markerStart].forEach(u), o.value.reduce((c, d) => ([d.markerStart, d.markerEnd].forEach(u), c.sort((h, p) => h.id.localeCompare(p.id))), s), s;
    });
    return (a, s) => (ae(), de("defs", null, [
      (ae(!0), de(ze, null, Tt(A(l), (u) => (ae(), rt(_d, {
        id: u.id,
        key: u.id,
        type: u.type,
        color: u.color,
        width: u.width,
        height: u.height,
        markerUnits: u.markerUnits,
        "stroke-width": u.strokeWidth,
        orient: u.orient
      }, null, 8, ["id", "type", "color", "width", "height", "markerUnits", "stroke-width", "orient"]))), 128))
    ]));
  }
}), Sd = { class: "vue-flow__edges vue-flow__container" }, Nd = {
  name: "Edges",
  compatConfig: { MODE: 3 }
}, Cd = /* @__PURE__ */ ve({
  ...Nd,
  setup(e) {
    const t = qe(bn), {
      edgesUpdatable: n,
      edgesFocusable: o,
      elementsSelectable: i,
      findNode: r,
      getEdges: l,
      getEdgeTypes: a,
      elevateEdgesOnSelect: s,
      dimensions: u,
      emits: c
    } = ye(), d = dn();
    function h(g) {
      return typeof g > "u" ? i.value : g;
    }
    function p(g) {
      return typeof g > "u" ? n.value : g;
    }
    function N(g) {
      return typeof g > "u" ? o.value : g;
    }
    function f(g, _) {
      const v = g || "default", b = t == null ? void 0 : t[`edge-${v}`];
      if (b)
        return b;
      let y = _ ?? a.value[v];
      if (typeof y == "string" && d) {
        const M = Object.keys(d.appContext.components);
        M && M.includes(v) && (y = pi(v, !1));
      }
      return y && typeof y != "string" ? y : (c.error(new Ee(_e.EDGE_TYPE_MISSING, y)), !1);
    }
    return (g, _) => A(u).width && A(u).height ? (ae(), de(ze, { key: 0 }, [
      (ae(), de("svg", Sd, [
        Fe(Ed)
      ])),
      (ae(!0), de(ze, null, Tt(A(l), (v) => (ae(), de("svg", {
        key: v.id,
        class: "vue-flow__edges vue-flow__container",
        style: De({ zIndex: A(nc)(v, A(r), A(s)) })
      }, [
        Fe(A(Fc), {
          id: v.id,
          edge: v,
          type: f(v.type, v.template),
          name: v.type || "default",
          selectable: h(v.selectable),
          updatable: p(v.updatable),
          focusable: N(v.focusable)
        }, null, 8, ["id", "edge", "type", "name", "selectable", "updatable", "focusable"])
      ], 4))), 128)),
      Fe(A(Zc))
    ], 64)) : Te("", !0);
  }
}), Md = /* @__PURE__ */ yt("div", { class: "vue-flow__edge-labels" }, null, -1), kd = {
  name: "Transform",
  compatConfig: { MODE: 3 }
}, $d = /* @__PURE__ */ ve({
  ...kd,
  setup(e) {
    const { id: t, viewport: n, d3Zoom: o, d3Selection: i, dimensions: r } = ye(), l = ue(!mi);
    return Ze(() => o.value && i.value && r.value.width > 0 && r.value.height > 0).toBe(!0).then(() => {
      setTimeout(() => {
        l.value = !0;
      }, 1);
    }), (a, s) => (ae(), de("div", {
      key: `transform-${A(t)}`,
      class: "vue-flow__transformationpane vue-flow__container",
      style: De({
        transform: `translate(${A(n).x}px,${A(n).y}px) scale(${A(n).zoom})`,
        opacity: l.value ? void 0 : 0
      })
    }, [
      Fe(Cd),
      Md,
      Fe(yd),
      Ne(a.$slots, "default")
    ], 4));
  }
}), Td = {
  name: "Viewport",
  compatConfig: { MODE: 3 }
}, Pd = /* @__PURE__ */ ve({
  ...Td,
  setup(e) {
    const {
      id: t,
      minZoom: n,
      maxZoom: o,
      defaultViewport: i,
      translateExtent: r,
      dimensions: l,
      zoomActivationKeyCode: a,
      selectionKeyCode: s,
      panActivationKeyCode: u,
      panOnScroll: c,
      panOnScrollMode: d,
      panOnScrollSpeed: h,
      panOnDrag: p,
      zoomOnDoubleClick: N,
      zoomOnPinch: f,
      zoomOnScroll: g,
      preventScrolling: _,
      noWheelClassName: v,
      noPanClassName: b,
      emits: y,
      connectionStartHandle: M,
      userSelectionActive: x,
      paneDragging: D,
      d3Zoom: V,
      d3Selection: H,
      d3ZoomHandler: I,
      viewport: Z,
      viewportRef: ee
    } = ye(), X = ue(), m = ue(!1), k = ue(!1), E = ue(!1), O = ue();
    let z = !1, G = 0, P = {
      x: 0,
      y: 0,
      zoom: 0
    };
    const U = $t(u), K = le(() => !m.value && p.value && U.value), L = le(
      () => s.value !== !0 && m.value || s.value === !0 && !K.value
    );
    We(() => {
      ul(X, oe);
      const Y = vo();
      to(Y, "resize", oe);
    }), We(() => {
      const Y = X.value, ie = Y.getBoundingClientRect(), ge = Lu().scaleExtent([n.value, o.value]).translateExtent(r.value), xe = ke(Y).call(ge), we = xe.on("wheel.zoom"), Ye = _t.translate(i.value.x ?? 0, i.value.y ?? 0).scale(st(i.value.zoom ?? 1, n.value, o.value)), w = [
        [0, 0],
        [ie.width, ie.height]
      ], C = ge.constrain()(Ye, w, r.value);
      ge.transform(xe, C), ge.wheelDelta($), V.value = ge, H.value = xe, I.value = we, Z.value = { x: C.x, y: C.y, zoom: C.k }, ee.value = Y, $t(s, (S) => {
        m.value = S;
      });
      const F = $t(a);
      po(() => {
        m.value && x.value && !k.value ? ge.on("zoom", null) : !m.value && !x.value && ge.on("zoom", (S) => {
          Z.value = { x: S.transform.x, y: S.transform.y, zoom: S.transform.k };
          const T = Q(S.transform);
          z = j(p.value, G ?? 0), y.viewportChange(T), y.move({ event: S, flowTransform: T });
        });
      }), ge.on("start", (S) => {
        var B;
        if (!S.sourceEvent)
          return null;
        G = S.sourceEvent.button, k.value = !0;
        const T = Q(S.transform);
        ((B = S.sourceEvent) == null ? void 0 : B.type) === "mousedown" && (D.value = !0), P = T, y.viewportChangeStart(T), y.moveStart({ event: S, flowTransform: T });
      }), ge.on("end", (S) => {
        if (!S.sourceEvent)
          return null;
        if (k.value = !1, D.value = !1, j(p.value, G ?? 0) && !z && y.paneContextMenu(S.sourceEvent), z = !1, te(P, S.transform)) {
          const T = Q(S.transform);
          P = T, y.viewportChangeEnd(T), y.moveEnd({ event: S, flowTransform: T });
        }
      }), po(() => {
        c.value && !F.value && !x.value ? xe.on(
          "wheel.zoom",
          (S) => {
            if (ne(S, v.value))
              return !1;
            S.preventDefault(), S.stopImmediatePropagation();
            const T = xe.property("__zoom").k || 1, B = un();
            if (S.ctrlKey && f && B) {
              const be = Oe(S), Ke = $(S), Nr = T * 2 ** Ke;
              ge.scaleTo(xe, Nr, be, S);
              return;
            }
            const W = S.deltaMode === 1 ? 20 : 1;
            let re = d.value === kt.Vertical ? 0 : S.deltaX * W, J = d.value === kt.Horizontal ? 0 : S.deltaY * W;
            !B && S.shiftKey && d.value !== kt.Vertical && !re && J && (re = J, J = 0), ge.translateBy(
              xe,
              -(re / T) * h.value,
              -(J / T) * h.value
            );
            const ce = Q(xe.property("__zoom"));
            clearTimeout(O.value), E.value || (E.value = !0, y.moveStart({ event: S, flowTransform: ce }), y.viewportChangeStart(ce)), E.value && (y.move({ event: S, flowTransform: ce }), y.viewportChange(ce), O.value = setTimeout(() => {
              y.moveEnd({ event: S, flowTransform: ce }), y.viewportChangeEnd(ce), E.value = !1;
            }, 150));
          },
          { passive: !1 }
        ) : typeof we < "u" && xe.on(
          "wheel.zoom",
          function(S, T) {
            if (!_.value || ne(S, v.value))
              return null;
            S.preventDefault(), we.call(this, S, T);
          },
          { passive: !1 }
        );
      }), ge.filter((S) => {
        var re, J;
        const T = F.value || g.value, B = f.value && S.ctrlKey;
        if ((p.value === !0 || Array.isArray(p.value) && p.value.includes(1)) && S.button === 1 && S.type === "mousedown" && ((re = S.target) != null && re.closest(".vue-flow__node") || (J = S.target) != null && J.closest(".vue-flow__edge")))
          return !0;
        if (!p.value && !T && !c.value && !N.value && !f.value || x.value || !N.value && S.type === "dblclick" || ne(S, v.value) && S.type === "wheel" || ne(S, b.value) && (!c.value && S.type !== "wheel" || c.value && S.type === "wheel") || !f.value && S.ctrlKey && S.type === "wheel" || !T && !c.value && !B && S.type === "wheel" || !p.value && (S.type === "mousedown" || S.type === "touchstart") || Array.isArray(p.value) && !p.value.includes(S.button) && (S.type === "mousedown" || S.type === "touchstart"))
          return !1;
        const W = Array.isArray(p.value) && p.value.includes(S.button) || !S.button || S.button <= 1;
        return (!S.ctrlKey || S.type === "wheel") && W;
      });
    });
    function j(Y, ie) {
      return ie === 2 && Array.isArray(Y) && Y.includes(2);
    }
    function $(Y) {
      const ie = Y.ctrlKey && un() ? 10 : 1;
      return -Y.deltaY * (Y.deltaMode === 1 ? 0.05 : Y.deltaMode ? 1 : 2e-3) * ie;
    }
    function te(Y, ie) {
      return Y.x !== ie.x && !isNaN(ie.x) || Y.y !== ie.y && !isNaN(ie.y) || Y.zoom !== ie.k && !isNaN(ie.k);
    }
    function Q(Y) {
      return {
        x: Y.x,
        y: Y.y,
        zoom: Y.k
      };
    }
    function oe() {
      if (!X.value)
        return;
      const { width: Y, height: ie } = pn(X.value);
      (Y === 0 || ie === 0) && y.error(new Ee(_e.MISSING_VIEWPORT_DIMENSIONS)), l.value.width = Y || 500, l.value.height = ie || 500;
    }
    function ne(Y, ie) {
      return Y.target.closest(`.${ie}`);
    }
    return (Y, ie) => (ae(), de(ze, null, [
      (ae(), de("div", {
        ref_key: "viewportEl",
        ref: X,
        key: `viewport-${A(t)}`,
        class: "vue-flow__viewport vue-flow__container"
      }, [
        Fe(vd, {
          "is-selecting": A(L),
          class: it({ connecting: !!A(M), dragging: A(D), draggable: !!A(p) })
        }, {
          default: je(() => [
            Fe($d, null, {
              default: je(() => [
                Ne(Y.$slots, "zoom-pane")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["is-selecting", "class"])
      ])),
      Ne(Y.$slots, "default")
    ], 64));
  }
}), Od = ["id"], Id = ["id"], Ad = ["id"], Dd = {
  name: "A11yDescriptions",
  compatConfig: { MODE: 3 }
}, zd = /* @__PURE__ */ ve({
  ...Dd,
  setup(e) {
    const { id: t, disableKeyboardA11y: n, ariaLiveMessage: o } = ye(), i = {
      position: "absolute",
      width: 1,
      height: 1,
      margin: -1,
      border: 0,
      padding: 0,
      overflow: "hidden",
      clip: "rect(0px, 0px, 0px, 0px)",
      clipPath: "inset(100%)"
    };
    return (r, l) => (ae(), de(ze, null, [
      yt("div", {
        id: `${A(qi)}-${A(t)}`,
        style: { display: "none" }
      }, " Press enter or space to select a node. " + zn(A(n) ? "" : "You can then use the arrow keys to move the node around.") + " You can then use the arrow keys to move the node around, press delete to remove it and press escape to cancel. ", 9, Od),
      yt("div", {
        id: `${A(Ki)}-${A(t)}`,
        style: { display: "none" }
      }, " Press enter or space to select an edge. You can then press delete to remove it or press escape to cancel. ", 8, Id),
      A(n) ? Te("", !0) : (ae(), de("div", {
        key: 0,
        id: `${A(Gu)}-${A(t)}`,
        "aria-live": "assertive",
        "aria-atomic": "true",
        style: i
      }, zn(A(o)), 9, Ad))
    ], 64));
  }
}), Bd = {
  name: "VueFlow",
  compatConfig: { MODE: 3 }
}, Wd = /* @__PURE__ */ ve({
  ...Bd,
  props: {
    id: null,
    modelValue: null,
    nodes: null,
    edges: null,
    edgeTypes: null,
    nodeTypes: null,
    connectionMode: null,
    connectionLineType: null,
    connectionLineStyle: { default: void 0 },
    connectionLineOptions: { default: void 0 },
    connectionRadius: null,
    isValidConnection: { type: Function, default: void 0 },
    deleteKeyCode: { type: [Boolean, String, Function], default: void 0 },
    selectionKeyCode: { type: [Boolean, String, Function], default: void 0 },
    multiSelectionKeyCode: { type: [Boolean, String, Function], default: void 0 },
    zoomActivationKeyCode: { type: [Boolean, String, Function], default: void 0 },
    panActivationKeyCode: { type: [Boolean, String, Function], default: void 0 },
    snapToGrid: { type: Boolean, default: void 0 },
    snapGrid: null,
    onlyRenderVisibleElements: { type: Boolean, default: void 0 },
    edgesUpdatable: { type: [Boolean, String], default: void 0 },
    nodesDraggable: { type: Boolean, default: void 0 },
    nodesConnectable: { type: Boolean, default: void 0 },
    nodeDragThreshold: null,
    elementsSelectable: { type: Boolean, default: void 0 },
    selectNodesOnDrag: { type: Boolean, default: void 0 },
    panOnDrag: { type: Boolean, default: void 0 },
    minZoom: null,
    maxZoom: null,
    defaultViewport: null,
    translateExtent: null,
    nodeExtent: null,
    defaultMarkerColor: null,
    zoomOnScroll: { type: Boolean, default: void 0 },
    zoomOnPinch: { type: Boolean, default: void 0 },
    panOnScroll: { type: Boolean, default: void 0 },
    panOnScrollSpeed: null,
    panOnScrollMode: null,
    zoomOnDoubleClick: { type: Boolean, default: void 0 },
    preventScrolling: { type: Boolean, default: void 0 },
    selectionMode: null,
    edgeUpdaterRadius: null,
    fitViewOnInit: { type: Boolean, default: void 0 },
    connectOnClick: { type: Boolean, default: void 0 },
    applyDefault: { type: Boolean, default: void 0 },
    autoConnect: { type: [Boolean, Function], default: void 0 },
    noDragClassName: null,
    noWheelClassName: null,
    noPanClassName: null,
    defaultEdgeOptions: null,
    elevateEdgesOnSelect: { type: Boolean, default: void 0 },
    elevateNodesOnSelect: { type: Boolean, default: void 0 },
    disableKeyboardA11y: { type: Boolean, default: void 0 },
    edgesFocusable: { type: Boolean, default: void 0 },
    nodesFocusable: { type: Boolean, default: void 0 },
    autoPanOnConnect: { type: Boolean, default: void 0 },
    autoPanOnNodeDrag: { type: Boolean, default: void 0 },
    __experimentalFeatures: null
  },
  emits: ["nodesChange", "edgesChange", "nodeDoubleClick", "nodeClick", "nodeMouseEnter", "nodeMouseMove", "nodeMouseLeave", "nodeContextMenu", "nodeDragStart", "nodeDrag", "nodeDragStop", "nodesInitialized", "miniMapNodeClick", "miniMapNodeDoubleClick", "miniMapNodeMouseEnter", "miniMapNodeMouseMove", "miniMapNodeMouseLeave", "connect", "connectStart", "connectEnd", "clickConnectStart", "clickConnectEnd", "moveStart", "move", "moveEnd", "selectionDragStart", "selectionDrag", "selectionDragStop", "selectionContextMenu", "selectionStart", "selectionEnd", "viewportChangeStart", "viewportChange", "viewportChangeEnd", "paneReady", "paneScroll", "paneClick", "paneContextMenu", "paneMouseEnter", "paneMouseMove", "paneMouseLeave", "edgeContextMenu", "edgeMouseEnter", "edgeMouseMove", "edgeMouseLeave", "edgeDoubleClick", "edgeClick", "edgeUpdateStart", "edgeUpdate", "edgeUpdateEnd", "updateNodeInternals", "error", "update:modelValue", "update:nodes", "update:edges"],
  setup(e, { expose: t, emit: n }) {
    const o = e, i = Mt(o, "modelValue", n), r = Mt(o, "nodes", n), l = Mt(o, "edges", n), { vueFlowRef: a, hooks: s, getNodeTypes: u, getEdgeTypes: c, ...d } = ye(o), h = hd({ modelValue: i, nodes: r, edges: l }, o, {
      vueFlowRef: a,
      hooks: s,
      getNodeTypes: u,
      getEdgeTypes: c,
      ...d
    });
    cc(n, s);
    const p = ue();
    return mt(bn, Ar()), hi(() => {
      h();
    }), We(() => {
      a.value = p.value;
    }), t({
      vueFlowRef: a,
      hooks: s,
      getNodeTypes: u,
      getEdgeTypes: c,
      ...d
    }), (N, f) => (ae(), de("div", {
      ref_key: "el",
      ref: p,
      class: "vue-flow"
    }, [
      Fe(Pd, null, {
        nodes: je(() => [
          (ae(!0), de(ze, null, Tt(Object.keys(A(u)), (g) => Ne(N.$slots, `node-${g}`)), 256))
        ]),
        edges: je(() => [
          (ae(!0), de(ze, null, Tt(Object.keys(A(c)), (g) => Ne(N.$slots, `edge-${g}`)), 256))
        ]),
        "connection-name": je(() => [
          Ne(N.$slots, "connection-line")
        ]),
        "zoom-pane": je(() => [
          Ne(N.$slots, "zoom-pane")
        ]),
        default: je(() => [
          Ne(N.$slots, "default")
        ]),
        _: 3
      }),
      Fe(zd)
    ], 512));
  }
}), Rd = {
  name: "Panel",
  compatConfig: { MODE: 3 }
}, qd = /* @__PURE__ */ ve({
  ...Rd,
  props: {
    position: null
  },
  setup(e) {
    const t = e, { userSelectionActive: n } = ye(), o = le(() => `${t.position}`.split("-"));
    return (i, r) => (ae(), de("div", {
      class: it(["vue-flow__panel", A(o)]),
      style: De({ pointerEvents: A(n) ? "none" : "all" })
    }, [
      Ne(i.$slots, "default")
    ], 6));
  }
});
export {
  En as BaseEdge,
  Pc as BezierEdge,
  ct as ConnectionLineType,
  at as ConnectionMode,
  Xd as EdgeLabelRenderer,
  bc as EdgeText,
  _e as ErrorCode,
  ft as GlobalVueFlowStorage,
  cn as Handle,
  Zn as MarkerType,
  fr as NodeIdInjection,
  kt as PanOnScrollMode,
  qd as Panel,
  Fu as PanelPosition,
  q as Position,
  so as SelectionMode,
  Ic as SimpleBezierEdge,
  wr as SmoothStepEdge,
  zc as StepEdge,
  Rc as StraightEdge,
  Wd as VueFlow,
  Ee as VueFlowError,
  ti as VueFlowInjection,
  Hd as addEdge,
  sn as applyChanges,
  Gd as applyEdgeChanges,
  Yd as applyNodeChanges,
  st as clamp,
  er as connectionExists,
  ed as defaultEdgeTypes,
  Qc as defaultNodeTypes,
  mr as getBezierEdgeCenter,
  yr as getBezierPath,
  Fd as getBoundsofRects,
  yn as getConnectedEdges,
  Wu as getIncomers,
  Qe as getMarkerId,
  rr as getNodesInside,
  Zu as getOutgoers,
  ir as getRectOfNodes,
  xr as getSimpleBezierPath,
  pr as getSimpleEdgeCenter,
  Jn as getSmoothStepPath,
  $c as getStraightPath,
  Yo as getTransformForBounds,
  tr as graphPosToZoomedPos,
  Be as isEdge,
  Yu as isGraphEdge,
  dt as isGraphNode,
  nt as isNode,
  qn as pointToRendererPoint,
  tr as rendererPointToPoint,
  Ld as updateEdge,
  Ud as useEdge,
  ld as useGetPointerPosition,
  br as useHandle,
  ud as useNode,
  ye as useVueFlow,
  Zd as useZoomPanHelper
};
